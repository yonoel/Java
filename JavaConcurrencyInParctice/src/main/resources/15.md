# 原子变量与非阻塞同步机制

为啥Semaphore或者ConcurrentLinkedQueue性能比内置锁性能高。

并发算法侧重于非阻塞算法，这种算法用底层的原子机器指令（比如CAG比较和交换指令）来代替锁。

## 锁的劣势

确保了独占访问和修改，并确保释放锁后，修改是可见的。

缺点：挂起线程与切换回来开销很大，而且长时间的中断。

锁对于细粒度的操作来说开销仍旧是巨大的。

## 硬件对并发的支持

独占锁是一个悲观技术，对于细粒度的操作，需要一种乐观的技术，更加高效。

### 比较并交换

CAS:V 读写的内存位置 ，A 进行比较的位置 ，B 拟写入的位置。当且仅当V的值等于A时，CAS才会通过原子方式用B值更新V值，否则不执行任何操作。无论位置
V的值是否等于A ，都将返回V的值。CAS的含义是，认为V的值应该是A ，如果是则将值更新为B ，否则不修改并告诉V的实际值是多少。

当多个线程尝试使用CAS 同时更新一个变量时，只有其中一个线程能更新变量值，而其他线程都将失败。然而失败的线程不会被挂起（锁就会挂起），而是告知在这次
竞争中失败，并且可以重试。因为竞争时不会阻塞，因此可以决定是重试还是做别的什么操作，这种灵活性大大减少了锁相关的活跃性问题。

### 非阻塞的计数器

见CasCounter,这个类不会阻塞，如果其他线程访问更新计数器，那么会多次执行重试操作。

### JVM对CAS的支持

## 原子变量类

### 原子变量是一种更好的volatile

将原子引用指向不可变对象的引用进行原子更新以避免竞态条件。

### 性能比较：锁与原子变量 

见ReentrantLockPseudoRandom,AtomicPseudoRandom.高度竞争的条件下，锁的性能超过了原子变量，但真实情况下，原子变量性能超过锁。（锁就相当于
红绿灯，原子变量相当于环岛，十分拥堵的路段那红绿灯好，一般拥堵的环岛就够了）

但是要意识到这种高度竞争不切实际，任何一个程序不会除去竞争锁，就不干别的事。原子变量的伸缩性高于锁。

## 非阻塞算法

在非阻塞算法里，不会出现死锁和优先级反正问题，但是会出现饥饿和活锁问题

### 非阻塞的栈

创建非阻塞算法的关键在于：找出如何将原子修改的范围缩小到单个变量上，同时维护数据的一致性。

见ConcurrentStack.非阻塞算法的特性：某项工作的完成具有不确定性，必须重试。

### 非阻塞的链表

见LinkedQueue，比较复杂，要考虑对头尾节点的快速访问，同时保证修改时，数据结构的完整。

### 原子的域更新器

ConcurrentLinkedQueue没有使用原子引用，使用了AtomicReferenceFieldUpdater来进行更新，之所以这样是为了提升性能，每次初始化一个原子引用。开销
大。

### ABA问题

ABA问题是一种异常现象，如果算法中的节点可以被循环使用，那么使用CAS就产生了这个问题（主要在没有垃圾回收的环境下）。比如V由A变成了B ，再由B变成，被认为
发生了变化，要求重新计算。

如果在算法里采用自己的方式管理对象内存就可能产生这个问题。解决方案：AtomicStampReference和AtomicMarkableReference