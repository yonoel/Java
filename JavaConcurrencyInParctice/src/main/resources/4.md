# 对象的组合

## 设计线程安全的类

设计线程安全的类，需要包含以下三要素
1.  找出构成对象状态的所有变量
2.  找出约束状态变量的不变性条件
3.  建立对象的并发访问策略

同步策略定义了如何在不违背对象不变条件或后验条件的情况下对其状态的访问操作进行协同。同步策略规定了如何将不可变性，线程封闭与加锁等机制结合使用。应当
将同步策略写为正式文档。

### 收集同步需求

如果不了解对象的不变性条件和后验条件，那么就不能确保线程安全性。要满足在状态变量的有效值或者状态转换上的各种约束条件，就需要借助于原子性和封装性。

### 依赖状态的操作

### 状态的所有权

大多数情况，所有权与封装性相互关联。多线程情况就共享所有权。

## 实例封闭

见personset.....

实例封闭是最简单的构建线程安全类的一个简单方式，还可以灵活地选择不同的锁。

### Java监视器模式

见PrivateLock,使用私有锁对象而不是内置锁对象。

### 示例：车辆追踪

见MonitorVehicleTracker,MutablePoint，尽管MutablePoint是非线程安全,但tracker是安全的，它包含的map和point都未曾发布。
尽管这种是可行但，但是在车辆容器很大的情况下，将极大的降低性能。如果频繁调用getLocation也是消耗巨大的。

## 线程安全性的委托

大多数对象都是组合对象，当从头开始构建一个对象，或者将多个非线程安全的类组合为一个类时，java的监视器模式很有用。

但是，若类中的每个组件都是线程安全的，我们是否也需要增加一个额外的线程安全层？视情况而定。如CountingFactorizer就是线程安全的，把此类的安全性委托
给了AtomicLong来保证。

### 示例：基于委托的车辆追踪

这个locations是实时的，缺点是，导致不一致的车辆位置视图，当然可以通过返回一个浅拷贝而非自身的方式来维持视图的统一。

### 独立的状态变量

这些变量，独立并没有耦合关系。见VisualComponent.

### 当委托失效时

见NumberRange，由于两个变量存在约束条件，尽管两个变量都是线程安全，都组合却是一个线程不安全的类。可以通过加锁避免，此外需避免发布lower和upper。
如果某个类存在一个复合性操作，那么仅靠委托不足以实现线程安全。这个类必须提供自己的加锁机制来保证复合操作都是原子性的，除非整个的复合操作都交给状态变量。

非常类似于volatile变量的问题。

### 发布底层的状态变量

如果一个状态变量是线程安全的，并且没有任何不变性条件来约束它的值，在变量上的操作也不存在任何不允许的状态转换，那么就可以发布此变量。

### 实例：发布状态的车辆追踪

见safePoint，PublishingVehicleTracker。其中safePoint不再是不可变的，但是是线程安全的，但是此point是实时的，如果需要校验这个point，显然就不能
采用这个方法。

## 在现有的线程安全类中添加功能

最简单实现，继承

### 客户端加锁机制

见ListHelper,这个putIfAbsent是非线程安全的，因为这个锁并不是list上的锁

要想方法正确执行，必须
1. 使list实现客户端加锁
2. 外部加锁时使用同一把锁

客户端加锁，指，对于使用某个对象X的客户端代码，使用X本身来保护其状态的锁来保护这段代码。比如这个list可以观看javadoc。
见SafeListHelper。不是很推荐，比较松散，难以管理。

 ### 组合
 
 更好的办法：组合。见ImprovedList-----就是代码过于冗余。。。,客户端把list交给此类后，只能通过此类访问，不在访问原先的list。此时的锁必然是自身的
 内置锁，而不关心扔进来的list是线程安全还是非安全的。
 
 ## 将同步策略文档化
 
 比如SimpleDateFormat是非线程安全的
 
 解释含糊的文档：有些文档不会解释它是否安全，要从实现角度考虑，它是否线程安全，比如Datasource，HttpSession
 
 
 