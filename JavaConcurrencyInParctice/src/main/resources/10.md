# 活跃性，性能与测试

## 死锁

### 锁顺序死锁

如果所有线程以固定的顺序来获取锁，那么就不会出现锁顺序死锁问题。

见LeftRightDeadLock，这种单独的分析，是可以正常运行的，但是是不够的，因为全局来看，并不知道对方这把锁发生了什么。

### 动态的锁顺序死锁

见TransferMoneyClass,事实上这个锁的顺序取决于传递给tranfermoney的参数顺序。如果一个线程从X到Y,另一个从Y到X.那么就
产生了死锁。

查看是否存在嵌套的锁获取操作。在制定锁顺序时，可以使用System.identityHashCode方法，该放回返回Object.hashcode
见TransferMoneyClass2.因为锁是个有向图，边就是争取的锁。通过识别hash值，固定了锁的顺序。
若hash值相同，可以引入一个tielock。

若在account中有一个唯一，不可变的并且具备可比性的键值，那么可以根据这个值进行上锁。

见DemonstrateDeadLock在大多数系统下很快发生死锁

### 在协作对象之间发生的死锁

见Taxi，Dispatcher,尽管没有方法会显示获得两个锁，但setLocation和getImage等方法的调用者都会获得两个锁。

在持有锁时调用某个外部方法，那么将出现活跃性问题。在这个外部方法可能获取其他锁（产生死锁），或者阻塞时间过长。

### 开放调用

如果在调用某个方法时不需要锁，那么这种调用被称为开放调用（Open Call）。依赖于开放调用的类通常表现更好。因此尽可能得编写开放调用的API。
见Taxi1,Dispatcher1。

在程序中尽量使用开放调用，与那些在持有锁时调用外部方法的程序相比，更易于死锁分析。

尽管这样会使得某个原子操作变为非原子操作，但是这样失去是可以接受的，因为这样的操作可能没有必要成为一个原子操作。

### 资源死锁

比如正当多个线程相互持有彼此互相等待的锁而不释放自己的锁，而产生死锁。

1.  链接两个数据库，A与D链接，需要E数据库的链接，B与E链接，等着D的链接。
2.  另一种基于资源的死锁就是线程饥饿死锁。一个任务提交一个任务并等待提交任务在单线程的Executor完成。

## 死锁的避免与诊断

如果需要获取多个锁，那么设计时就要考虑顺序，尽量减少锁交互的数量，并且写入文档。

### 支持定时的锁

用来检测死锁和死锁恢复，即显式的使用Lock类中的定时tryLock来替代内置的锁。当使用锁时，只要没有锁就会一致等待，而这个锁可以设置一个超时时间。

### 通过线程转储信息来分析死锁

JVM通过Thread DUMP来识别栈，堆信息。
UNIX上测试，可以想JVM进程发送Sigquit 信号或者ctrl +  \，windows环境 ctrl+break。

如果用Lock类，java5不支持提示，java6支持但精确度不高，因为内置锁和线程栈关联，显式锁和获得它的线程关联。

## 其他活跃性危险

### 饥饿

当线程由于无法访问它需要的资源而不能继续执行，就发生了饥饿。最常见的时CPU资源。尽量不要改变线程的优先级。

要避免使用线程优先级，因为这会增加平台依赖性，并导致活跃性问题。在大多数并发应用程序中，都可以使用默认的优先级。

### 糟糕的响应性

### 活锁

该问题尽管不会阻塞线程，但也不能继续执行，因为线程会不断重复执行相同但操作，而且总会失败。活锁通常发生在事务消息里。解决方案：随机性。
 




