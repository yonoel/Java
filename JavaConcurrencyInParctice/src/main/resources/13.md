# 高级主题

介绍ReentrantLock（重入锁）

## Lock与ReentrantLock

1.5之前只有synchronized,见Lock接口,1.5后有ReentrantLock，ReentrantReadWriteLock
1.8有StampedLock

因为内置锁无非实现非阻塞结构的加锁机制。比如无法中断一个正在获取锁的线程，无法在请求获取一个锁时无限等待，内置锁必须在获取该锁的代码块中释放。
见LockExample，需要finally来释放锁。因为没有记录应该释放锁的位置和时间，这就是为啥不能替代内置锁的原因，因为它不会自动清除锁。

### 轮询锁与定时锁

在内置锁里，死锁是个严重的问题，只能重启，而防止死锁的唯一方法就是避免出现不一致的锁顺序。

见NewTransferMoney,TimeLockExample

### 可中断的锁的获取操作

见TimeLockExample,lockInterruptibly方法能够在获得锁的同时保持对中断的响应

### 非结构块的加锁

内置锁的获取和释放都是基于代码块，有了这lock以后可以连锁式加锁或者锁耦合。类似锁分段技术。

## 性能考虑

## 公平性

lock的构造有公平锁和非公平锁

+   公平锁：线程将按照它们发出请求的顺序来获得锁
+   非公平锁：允许插队

信号量同样可以采用非公平的获取顺序，

通常，非公平锁的性能高于公平锁。

当持有锁的时间较长，或缺请求锁的间隔较长，使用公平锁。

## 在synchronized和ReentrantLock之间选择

仅当内置锁不能满足需求时，才使用。比如，可定时的，可轮询的与可中断的锁获取操作，公平队列，以及非块结构的锁。否则还是用内置锁。

## 读写锁

ReentrantLock实现了一种标准的互斥锁，每次最多只有一个线程能够持有ReentrantLock。

在这种情况下可以使用这种锁：一个资源被多个读操作访问，或者被写访问，但两者不能同时进行。

ReadWriteLock，读写之间的交互有多种实现方式，有以下可选的实现：
+   释放优先，当一个写入操作释放写入锁时，并且队列中同时有读和写，那么优先选读还是写，还是最先的请求？
+   读线程插队，如果读锁占有，此时写锁等待，那么新到达的读锁线程能否插队？
+   重入性
+   降级，如果一线程占有写锁，能否在不释放写的情况下获取读锁。
+   升级，读锁线程能否升级为写锁（大多数不支持）

构造可以选择公平锁还是非公平锁（默认）。
公平：假设读锁占有，写锁优先占有。
非公平：插队，写锁可以降级，读锁不能升级

写入锁只能有唯一的所有者，并且只能由该线程释放。

当锁持有的时间较长并且大部分操作不会修改值时，读写锁的性能很高。见ReadWriteMap。



