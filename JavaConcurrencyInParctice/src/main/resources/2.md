# 线程安全性

简介：
要编写线程安全的代码，核心在于要对状态访问操作进行管理，特别是对共享的和可变的状态的访问。

一个对象是否需要线程安全，取决于他是否被多个线程访问，这指的是在程序中访问对象的方式，而不是对象实现的功能。
    
如果当多个线程访问同一个可变当状态变量时没有适用同步技术，那么程序就可能出错。有三种方式修复
+ 不在线程之间共享该状态变量
+ 将状态量修改为不可变的数量
+ 在访问状态变量时使用同步

在任何情况下，只有当类中仅包含自己的状态时，线程安全类才是有意义的。

## 什么是线程安全

+ 正确性
某个类的行为和其规范（api描述）完全一致。单线程的正确性近似定义为所见即所知。多线程类似：当多个线程访问某个类时，不管运行时环境采用何种调度方式
或者这些线程如何交替执行，并且在主调代码中不需要任何额外的同步或协同，这个类始终表现正确的行为。

见StatelessFactorizer，此对象，不包含任何域，不包含对其他类中域的引用。计算过程中的临时状态仅存在于调用栈上的局部变量，并且只能由正在执行的线程访问。访问
此servlet的线程不会影响另一个访问此servlet的线程的计算结果，因此没有共享状态。

无状态对象一定是线程安全的。

## 原子性

见UnsafeCountingFactorizer，尽管单线程环境下没有问题。
在并发编程中，这种由于不恰当的执行顺序而出现不正确的结果是一种非常重要的情况，名字为：竞态条件（RaceCondition）

### 竞态条件

+ 先检查在执行
+ 事情发生的顺序互相牵制

本质就是，基于一种可能失效的观察结果来作出判断或者执行某个计算

### 延迟初始化中的竞态条件

见LazyInitRace。
UnsafeCountingFactorizer存在另一种竞态条件，在"读取-修改-写入"中，基于对象之前的状态来定义对象状态的转换。
要确保在执行更新的过程中没有其他线程修改或者使用。

### 复合操作

LazyInitRace，UnsafeCountingFactorizer都包含一组需要以原子方式执行（不可分割）的操作。要避免竞态条件问题，
就必须在某个线程修改该变量时，通过某种方式防止其他线程使用这个变量，从而确保其他线程只能在该线程操作完后操作，而不是在操作过程中。

见CountingFactorizer中采用AtomicLong类型

## 加锁机制

见UnsafeCachingFactorizer，其不变性条件之一是，在lastFactors中缓存的因数之积应等于lastNumber的缓存值。当不变性条件涉及
多个变量时，各个变量之间并不是互相独立的，而是某个变量的值会对其他变量的值产生约束。因此当更新某一个变量时，需要在同一个原子操作中对其他变量同时进行更新。

### 内置锁

即同步代码块。同步代码块包括两个部分：一个作为锁对象的引用，一个作为由这个锁保护的代码块。

每个java对象都有一个实现同步的锁，被称为内置锁或监视器。线程进入时获得锁， 离开时释放锁。此锁时个互斥锁。
见SynchronizedFactorizer,不过性能低下，不要这么做

### 重入

内置锁是可以重入的。重入的实现一种方式就是为每个锁设计一个线程持有，还有一个计数器。计数器为0，解锁。若为同一个线程请求锁，计数器递增，释放锁，计数器递减。

比如子类重写了父类的同步方法，见Widget，并且调用了父类的此方法，那就是有两把锁，但是子类调用时先获取了父类的锁。
那么当子类调用父类方法时又需要这把锁。如果锁在这里不能重入，那么就产生死锁。

## 用锁来保护状态 

对于可能被多个线程同时访问的可变状态变量，在访问它时需要持有同一个锁，在这种情况下，我们称状态变量由锁保护。

对象的内置锁和其状态之间没有内在的关联，虽然大多数类都将内置锁用作一种有效的加锁机制，但对象域不一定要通过内置锁来保护。
当获取与对象相关联的锁时，并不能阻止其他线程访问该对象。之所以每个对象都有个内置锁，只是为了免去显式地创建锁对象。

一种常见的约定是，将所有可变状态都封装在对象内部，并通过对象锁来锁定这些状态。比如并发的集合类。

只有被多个线程同时访问的可变数据才需要通过锁保护

当不变性条件涉及多个状态变量时，那么还需要另一个需求：每个涉及的变量都由同一个锁来保护。

## 活跃性和性能

通过缩小同步代码块的作用范围，就能提高性能。
见CachedFactorizer，没有使用Atomic，因为已经使用了同步代码块，如果同时使用两种同步机制，可能会带来混乱。

当执行较长的计算或者耗时比较久的操作，一定不要持有锁。









