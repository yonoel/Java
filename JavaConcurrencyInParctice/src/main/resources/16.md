# Java内存模型

## 什么是内存模型，为啥需要它

假设 a = 3,内存模型解决了这个问题，什么条件下，读取a的线程将看到值为3。

JVM只需实现一种类似串行的语意：只要程序的最终结果与在严格串行环境中执行的结果相同，允许重排，允许变量存储在寄存器啊吧啦吧啦。

JMM规定了JVM必须遵循的一组最小保证，规定了对变量的写入操作在何时将对于其他线程可见。

### 平台的内存模型

每个处理器都有自己的缓存，并且定期与主内存进行同步。缓存一致性的条件并不相同。有一种特殊指令叫做内存栅栏，确保数据可见性。

### 重排序

见PossibleReordering

### java内存模型简介

java对所有操作定义了一个偏序操作，称为Happens-before

### 借助同步

Piggyback现有的同步机制，比较高级，不推荐,使用见FutureTask的内部类AQS的整数来保存任务当前的状态，同时有一个结果result，自然这些变量需要按照Happens
-Before来排序

## 发布

### 不安全的发布

见UnsafeLazyInitialization

除了不可变对象外，使用另一个线程初始化的对象通常是不安全的，除非对象的发布操作是在使用该对象的线程开始使用之前执行。

### 安全的发布

Happens-Before比安全发布提供了更强可见性与顺序保证。因为此规则是内存访问级别的，而发布则是程序设计的需要。

### 安全初始化模式

见SafeLazyInitialization
见EagerInitialization
见HolderInitialization

### 双重检查

千万不要使用见DoubleCheckedLocking.线程可能看到一个仅被部分构造的实体，仅解决了独占性，没有解决可见性。

真正问题在于，在没有同步的情况读写一个共享对象，可能看见一个失效值，DCL通过在持有锁的情况来尝试避免这种风险。然而
线程看到的是引用的当前值，而对象的状态值可能还是失效。

解决方案：加volatile

还是不推荐使用DCL ,因为DCL的原因是无竞争同步执行速度慢，和JVM启动慢已经不存在了。

## 初始化过程中的安全性

如果对象是不可变的，那么UnSafeLazy。。。也是安全的。

初始化安全确保，对于被正确构造的对象，所有线程都看到由构造函数为对象各个final设置正确的值，而不管使用何种方式来发布。

见SafeStates,无论怎样发布它都是线程安全的。

如果states不是final，或者存在除了构造以外其他的函数可以修改states，那么不能确保缺少同步的情况下安全访问states，
如果还存在其他变量不是final，那么这些变量也有可能是不正确的值，从而导致初始化安全失败。