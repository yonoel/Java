# 2.2 归并排序
本节所有算法都基于归并操作，即将两个有序数组归并成一个更大都有序数组。人们就依据这个操作
发明了一种简单的递归排序算法，归并排序。先递归地将数组分成2份分别排序，最后归并结果。
优点是，保证了长度为N的数组所需时间为NlgN成正比，缺点就是需要额外的空间。
## 2.2.1 原地归并的抽象方法
直截了当的方式就是将两个不同的有序数组归并到第三个数组，但是当归并一个大数组时，显然要进行多次
归并，每次创建一个新数组明细开销过大。希望有一种原地归并当方法，你可以思考一下，相对于使用额外空间
实现都复杂。
## 2.2.2 自顶向下的归并
嫌弃merge太麻烦，采用分治思想，递归调用方法，既然能将2个子数组排序，就能通过
归并2个子数组来将整个数组排序

sort(a,0,mid);
sort(a,mid,hi);
merge(a,0,mid,hi)

树状结构图，每个节点都表示一个sort方法通过merge合并的子数组。这棵树有n层，
对于0到n-1之间的k，自顶向下的第k层有2^k个子数组，每个数组长度且为2^n-k，因此
每层需要2^k * 2^n-k = 2^n次比较，共需要n*2^n次比较；
很明显树的层树是lgN，因此比较也就是NlgN

命题，对于长度N的数组，自顶向下归并排序需要1/2NlgN到NlgN次比较

证明，。。。。

#### 2.2.2.1 对小规模子数组使用插入排序
#### 2.2.2.2 测试数组是否有序
#### 2.2.2.3 不将元素复制到辅助数组
我们可以节省将数组复制到用于归并到辅助数组到时间（空间不行）
要做到这一点，我们要调用两种排序，1是将数据从输入数组排序到辅助数组
2是将数据从辅助数组排序到输入数组

### 2.2.3 自底而上底归并排序
先归并小型数组，在成对归并得到的数组，通过控制每个子数组的大小sz，来归并

命题H，对于长度为N的数组，自底向上的归并排序需要1/2NlgN 至 NlgN次比较，最多
访问数组6NlgN次。

当数组长度为2的幂时，两种归并的次数相同，只是顺序不同。

自底向上的归并适合链表结构，因为只需要重新组织链表链接，不需要创建新的节点。

### 2.2.4 排序算法的复杂度
研究复杂度的第一步是建立一个计算模型

命题I，没有任何基于比较的算法能够保证使用少于lg(N!)~NlgN次比较将长度为N的数组排序

证明，首先假设没有主键重复，我们使用二叉树来表示所有的比较，那么树中的节点要么是一片叶子，
表示排序完成且结构为a[0],a[1]...a[i]，要么是一个内部结点，表示a[i]-a[j]之间的一次比较操作

首先这棵树至少有N!个叶子节点，因为N个不同的主键有N!种不同的排列，从根节点到叶子节点的
内部节点的数量既是某种算法的比较次数，因为二叉树高度为h，最多有2^h个节点

因此得到结论，归并排序是一种渐进最优的基于比较排序的算法。
#Q&A

 