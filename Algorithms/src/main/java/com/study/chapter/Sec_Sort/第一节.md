# 2.1 初级排序算法
## 2.1.1 游戏规则
定下模版类
### 2.1.1.1 验证
### 2.1.1.2 运行时间
### 2.1.1.3 额外的内存使用
### 2.1.1.4 数据类型
## 2.1.2 选择排序
选择最小的放第一个位置，如此往复，选择排序

交换的总次数是，时间效率取决于比较的次数，大约需要N^2/2和N次交换
比较总数是（N-1）+(N-2).....1 = N(N-1)/2

## 2.1.3 插入排序
桥牌的整理方法，将牌插入到合适的位置

命题：平均需要N^2/4次比较和交换，最差是N^/2次比较和交换，最好是N-1次比较和0次交换

插入排序对以下几种部分有序的数组很有效
+ 数组中每个元素离他最终的位置不远
+ 一个有序的大数组接着一个小数组
+ 数组中只有几个位置不正确
## 2.1.4 排序算法的可视化
## 2.1.5 比较两种算法
+ 实现并调试
+ 分析基本性质
+ 对其性能进行猜想
+ 实验验证

第一步以及实现，命题A,B,C完成第二步，命题D完成第三步，第四步用SortCompare类

D：对于随机排序无重复主键的数组，插入和选择排序运行时间都是平方级别的，两者之比是一个较小的常数

## 2.1.6 希尔排序
基于插入排序。插入排序对于大规模乱序很慢，因为只交换相邻的元素，因此元素只能一点点移动。

希尔的思想是这样的，数组中任意间隔为h的元素都是有序的。这样的数组称为h有序数组，对于每个h数组进行
插入排序，但因为子数组相互独立，更简单的方式在子数组中将每个元素移动由1改为h，这样希尔排序的
实现就转换为类一个类似于插入排序但使用类不同增量的过程。

h的大小未定。。。取不出最好的

和选择以及插入排序相比，希尔排序可以用于大型数组，数组越大，优势越大。
# Q&A
没做


