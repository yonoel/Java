# 2.4 优先队列
先讨论基本表示形式（其一或两种操作都在线性时间完成）
之后讨论基于二叉堆数据结构的一种优先队列的经典实现

## 2.4.1 API
      API
      public class MaxPQ<Key extends Comparable<Key>>
                MaxPQ()
                MaxPQ(int max)
                MaxPQ(Key[] a)
      void      Insert(Key a)
      Key       Max()
      Key       delMax()
      boolean   isEmpty()
      int       size()
      
## 2.4.2 初级实现
### 2.4.2.1 数组实现（无序）
### 2.4.2.2 数组实现（有序）
### 2.4.2.3 链表表示
对于栈和队列，我们的实现能够在常数时间完成操作；而对于优先队列，插入和删除在最坏情况
需要线性时间完成。接下来需要讨论的数据结构，保证这两个操作更快地执行。

        优先队列的各种实现在最坏情况下的运行时间的增长数量级别
        数据结构            插入          删除
        有序数组            N               1
        无序数组            1               N
        堆                 lgN             lgN
        理想情况            1               1
        
## 2.4.3 堆的定义
数据结构二叉堆能很好的实现优先队列。在二叉堆的数组中，每个元素都要保证大于等于另
两个特点位置的元素。

定义：当一棵二叉树的每个节点都大于等于它的两个子节点时，被成为堆有序

二叉堆表示法：
如果我们用指针表示二叉堆，那么每个元素都需要三个指针来表示它的上下节点。
但我们使用完全二叉树，就比较方便了。完全二叉树只用数组，不需要指针就可以表示，
将二叉树的节点按照层级顺序放入数组。

定义：二叉堆是一组能够用堆有序的完全二叉树排序的元素，并在数组中按照层级排序（不使用第一个位置）

显而易见，在堆中，位置k的父节点位置在k/2，子节点在2k和2k+1。
用堆实现的完全二叉树结构严格，然而灵活性值得这么做。利用数组无需指针就能沿着
树结构，上下移动，同时还保证了算法的对数复杂度的性能。
## 2.4.4 堆的算法
用N+1的数组pq【】表示一个大小为N的堆，不使用0下标。在排序中，只通过less和exch来操作。
堆的操作会首先进行一些简单的改动，打破堆的状态，然后遍历堆并按照要求将堆的状态恢复。这个过程被称为堆堆有序化。

有序化会遇到两种情况
+ 当某个节点的优先级上升（或是堆底加入一个新的节点），我们需要由下至上地恢复堆堆顺序。
+ 当某个节点的优先级下降，需要由上至下地恢复堆的顺序

### 2.4.4.1 由下至上的堆有序化，上浮
（就是插入的节点比父节点大，所以向上浮动）
### 2.4.4.2 由上至下的堆有序化 下沉
插入元素，合理上浮

删除最大元素，删除根节点，把最后堆元素放到堆顶，然后下沉
 
命题Q，对于含有N个元素的基于堆的优先队列，插入元素操作只需不超过(lgN+1)次比较，删除
最大元素的操作需要不超过2lgN次比较。

### 2.4.4.3 多叉堆
基于用数组表示的完全三叉树构造，并修改相应的代码不难，对于位置k的节点，大于等于位于3k-1,3k,3k+1的节点；
小于等于(k+1)/3的节点，甚至对于给定的d，将其修改成任意的d叉树都不难

### 2.4.4.4 调整数组大小
这样时间纬度就上升为N了

### 2.4.4.5 元素的不可变性
### 2.4.4.6 索引优先队列
在许多app中，允许调用已经进入队列中的元素是很常见的，简单方法就是给予每个元素一个索引。

另一种常见情况是，app里已经有里总量为N的多个元素，而且同时使用了多个平行数组来存储这些元素的信息，此时
其他无关的代码里可能已经使用里一个索引来引用这些元素。

        关联索引的泛型优先队列的API
        
        class           IndexMinPQ<Item extends Comparable<Item>>
                        IndexMinPQ(int maxN)索引取值范围是0至maxN-1
       void             insert(int k, Item item)
       void             change(int k, Item item)
       boolean          contains(int k)
       void             delete(int K)
       Item             min()
       int              minIndex()
       int              delMin()
       boolean          isEmpty()
       int              size()
      
将它看成一个能够快速访问其中最小元素的数组
### 2.4.4.6 索引优先队列用例
下面的Multiway例子解决来多向归并问题：将多个有序的输入流归并成一个有序的输出流
## 2.4.5 堆排序
任意的一种优先队列变成一种排序方法。先插入优先队列，然后一个个删除，用无序
数组这么做相当于在做插入排序，如果用堆堆优先队列来做则是一种新的排序。

堆排序分为两个阶段，在堆的构造阶段中，我们将原数组重新组织安排进一个堆中；

然后下沉排序，我们从堆中递减顺序取出元素。

### 2.4.5.1 堆的构造
由N个给定元素构造一个堆有多难？N*lgN完成，从左到右扫描swim完成。
重写了堆构造，不用上浮，用下沉，堆构造：
1.更高效的，从右到左扫描用sink，构造子堆，数组里的每个位置都是一个子堆堆根节点，
如果一个节点堆两个子节点都是堆，继续调用sink，递归地建立堆，我们只需要扫描
数组中一半的元素，我们可以跳过大小为1的子堆（递归处理子堆，除了根节点）
2.最后在位置1的地方调用sink（处理根节点）

命题，用下沉操作由N个元素构造堆只需要少于2N次比较以及少于N次交换

证明，比如构造一个127个元素的堆，先处理32个大小为3的子堆，在处理16个大小为7的堆
，在处理8个大小为15的堆，4个大小为31的堆，2个大小为63的堆，和1个127的堆，因此
需要32*1+16*2+8*3+4*4+2*5+1*6=120次交换

### 2.4.5.2 下沉排序
主要在下沉排序里，进行里排序，删除根节点，然后放入堆缩小后数组中空出的位置。
这里快的主要原因是不用遍历比较

命题S，将N个元素排序，堆排序只需少于2NlgN + 2N次比较 以及一半的次数的交换

证明，2N来自堆的构造，2NlgN来自下沉操作的比较，最多为2lgN，见命题P和Q

### 2.4.5.3 先下沉后上浮
大多数在下沉排序期间插入堆的元素直接加入到堆底。在下沉中总是直接提升较大的子节点直至堆底
，然后在使元素上浮，可以减少比较次数。缺点是需要额外堆空间

堆排序在排序复杂性的研究中有着重要的地位，因为它是唯一能同时最优地利用空间和
时间的方法。现代系统比较少使用，因为无法利用缓存，但嵌入式开发需要，因为内存有限。

但是基于堆的优先队列越来越重要，因为它的插入和删除保证了对数级别的操作时间。

#Q&A       
        
         