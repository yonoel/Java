# 无向图
边（edge）是两个顶点（vertex）之间的链接，无向图，最简单的图模型。

定义，图是由一组顶点和一组能够将两个顶点相连的边组成的。

一般使用0 至 V-1来表示 V个顶点的图中的各个顶点。我们用V-W表示链接V-W的边。
图的构成只有无序的顶点和边。

特级的图，我们允许出现两种简单而特殊的情况
+ 自环，即一条链接一个顶点和其自身的边
+ 链接同一对顶点的两条边称为平行边
## 4.1.1 术语表
1. 当两个顶点通过一条边相连时，我们称这两个顶点是相邻的，并称链接依附于这两个顶点。
2. 某个顶点的度数即为依附它的边的总数。
3. 子图是一幅图的所有边的一个子集（以及它们所依附的所有顶点）组成的图。（无边的顶点不算咯）

定义，
+ 在图中，路径是由边顺序链接的一系列顶点。
+ 简单路径是一条没有重复顶点的路径。
+ 环是一条至少含有一条边且起点和终点相同的路径。
+ 简单环是一条（除了起点和终点相同之外）不含有重复顶点和边的环。
+ 路径或者环的长度为其中所包含的边数。

当两个顶点之间存在一条链接双方的路径时，我们称两个顶点是连通的。
用类似u-v-w-x来表示u-x的一条路径，用u-v-w-x-u表示环。

定义，如果从任意一个顶点都存在一条路径到达另一个任意顶点，这幅图被称为连通图。
一副非连通图由若干连通的部分组成，它们都是其极大连通子图。

一般来说，处理图，就是需要一个个处理它的子图（连通分量）

无环图是不包含环的图。

定义，树是一幅无环连通图。互不相连的树组成的集合称为森林。

连通图的生成树是他的子图，它含有图中的所有顶点，且是一棵树，图的生成森林是它的所有连通子图的生成
树的集合。

当且仅当含有V个节点的图G满足下列五个条件之一时，它是一棵树：
+ G有V-1条边，且没有环
+ G有V-1条边，且连通
+ G是连通的，但删除任意一边都使其不再连通（没有一条边是环）
+ G是无环图，但添加任意一边都会使其产生一条环
+ G中任意一对顶点仅存在一条简单路径（两个的话，就是环？）

图的密度是指已经链接的顶点对 占 所有可能被链接的顶点对的比例。

在稀疏图中，占比比较低，稠密图，占比高。
一般情况下，如果一幅图中不同边的数量只占顶点总数的一小部分，那就是稀疏的。

二分图是一种能将所有节点分为两部分的图（红黑树呗。。。）

## 4.1.2 表示无向图的数据类型
        无向图的API
        
        public          class       Graph
                                    Graph(int V)
                                    Graph(In in)
                        int         V()
                        int         E()
                        void        addEdge(int v, int w)
        Interable<Integer>          adj(int v)返回所有和V相邻的所有顶点
                        String      toString()
所有算法都基于adj的基本操作

第二个构造函数接收的输入由2E + 2 个整数，首先是V其次是E，再然后是 E对0 - V-1 之间的整数，
每个整数对表示一条边。
### 4.1.2.1 图的几种表示方法
用那种数据结构来表示图，并实现，有以下要求
+ 必须为碰到的各种类型的图留下足够的空间
+ 实现一定要快。。

有三种选择
+ 链接矩阵。V*V的boolean矩阵，相连就是true，很明显。。空间不足，而且不能展示平行边
+ 边的数组。使用一个Edge类，简洁，但是无法快，实现adj时要检查所有的边。。和顶点
+ 链接表数组。使用一个以顶点为索引的列表数组，其中每个元素都是和该顶点相邻的顶点列表（hash表啊！）
### 4.1.2.2 链接表的数据结构
使用bag实现链表结构，
这种实现的性能有以下特点：
+ 使用的空间和 V + E 成正比
+ 添加一边所需时间为常数
+ 遍历顶点V 的所有相邻顶点所需实现和V的度数（边数）成正比，成常数

见graph

在实际应用中可能还有以下操作
+ 添加或者删除一个顶点（用符号表替代数组就可以实现）
+ 删除一条边
+ 检查图里是否含有边V-（用Set替代bag 这种被称为链接集）

本书不使用以上的算法，因为
+ 不需要添加删除顶点和边，或是检查边是否存在
+ 由于链接表很短，因此可以直接穷举遍历链表
+ 使用set和符号表，会是算法更复杂
+ 在某些情况，会使性能损失

        典型的Graph 实现的性能复杂度
       数据结构             所需空间            添加一条边           检查顶点是否相邻            遍历v的所有相邻顶点
       边的列表                E                   1                    E                      E
       链接矩阵                V^2                 1                    1                      V
       链接表                  E+V                 1                   degree(v)             degree(v)
       链接集                  E+V                 logV                logV                 logV+degree(v)
      
### 4.1.2.3 图的处理算法设计模式
因为我们要研究的是图的处理，因此把图的表示和处理分离。先见Search类
## 4.1.3 深度优先搜索（所有路径遍历）
### 4.1.3.1 走迷宫
用迷宫代替图，通道代替边，路口代替顶点，米诺陶的迷宫，Tremaux搜索,探索所有通道
+ 选择一条没有标记过的通道，铺上绳子。
+ 标记第一次路过的路口和通道。
+ 当来到一个标记过的路口时回退到上个路口。
+ 当回退到的路口已经没有可走的通道时，继续回退。

绳子保证你找到一条出路，标记则保证你不会两次经过同一条通道或者同一个路口。
### 4.1.3.2 热身
搜索连通图的经典递归算法（遍历所有顶点和边）和Tremaux搜索类似，只需一个递归方法来遍历所有顶点。
在访问其中一个顶点时
+ 将它标记为已访问
+ 递归地访问它的所有没有被标记的邻居顶点

这种方法称为深度优先搜索（DFS）。

命题A ， 深度优先搜索标记 与 起点连通的所有顶点 所需的时间 和顶点的度数之合成正比。

证明。。。。。。因为通过adj，即通过边找到了连通的顶点 
### 4.1.3.3 单向通道
### 4.1.3.4 跟踪深度优先搜素
### 4.1.3.5 深度优先搜索的详细轨迹
问题，两个顶点是否连通？和两个顶点是否存在路径，其实等价。但是1.5的UF并不能找出路径，
深度优先搜索是第一个能解决这个问题的算法，它能解决的问题如下：

单点路径：给定一幅图和一个起点s，回答从s到给定目的地v是否存在一条路径，若存在，找出该路径

## 4.1.4 寻找路径
见path的
### 4.1.4.1 实现
见DepthFirstPaths
### 4.1.4.2 详细轨迹
DeptjFirstPath基于DepthFirstSearch，但是新增了功能

命题A 续，使用深度优先搜索得到的从给定起点到任意标记顶点的路径所需的时间与路径长度成正比

证明，因为edgeTo是一棵以起点为根节点的树

## 4.1.5 广度优先搜索
单点最短路径，解决这个问题需要广度优先，深度优先就像是一个人再走迷宫，遍历所有路径，
广度优先就是一堆人再走迷宫，每个人都有绳子，绳子可以共用，因此能找到最短路径。

在程序里，搜索路径时，可能遇到多条边都要搜索，我们选择其中一条进行搜索，先下压，这就是深度优先 。

广度就是，希望按照与起点距离最短的顶点来遍历，用队列来实现。

实现。

使用一个队列保持所有被标记过的但其邻接表还未被查询过的顶点。然后重复以下步骤：
+ 取队列中的下一个顶点，并标记
+ 将与V相邻的所有未被标记的顶点加入队列

命题B ，对于从s可达的任意顶点v，广度搜索都能找到一条最短路径。

证明，因为从队列里包含了0到N个到起点距离为K到顶点m，以及距离为K+1的顶点n
,其中k为整数，初始值为0。这意味，顶点是按照他们和起点的距离的顺序加入或者离开队列的。
从v加入队列到离开队列，不可能找出比到v更短的路径，而在v离开队列以后的所有到v的路径，不可能短于v在树中的路径。

命题B ， 续，广度优先搜索所需的时间在最坏的情况下和V + E 成正比

证明， 如同深度优先，依旧与度数成正比。

广度优先是扇形扫描，以广度为优先原则。
深度优先是一路走到底，不行再退。

## 4.1.6 连通分量
可以用来寻找子图个数

           连通分量的API
      public            class           CC
                                        CC(Graph g)
                        boolean         connected(int v, int w)
                        int             count()
                        int             id(int v)
### 4.1.6.1 实现
基于深度优先实现。

命题C ， 深度优先的预处理时间和空间与V+E成正比，且在常数时间内处理关于图的连通性查询。

证明，  每个链接表的元素只会被检查一次，共有2E个元素（每条边两个）。
### 4.1.6.2 union-find 算法
CC里基于深度优先的解决连通性和第一章的union-find（树结构）算法相比孰优孰劣？

理论上，深度优先快，但在实际中，这点差异微不足道，并且union-find更快，因为它不需要构造图。
更重要的是，union-find是一种动态算法，但深度优先搜索则必须要对图进行预处理。

检测环，    给定图是无环图？

双色问题，  能够用两种颜色将图的所有顶点着色，使得任意一条边的两个端点都不相同？这个问题等价于，这是一幅二分图？
## 4.1.7 符号图
在典型应用中，图是通过文件或者网页定义，使用字符串来表示顶点。
+ 顶点名为字符串
+ 用指定分隔符来隔开顶点
+ 每一行都表示一组边的集合，每条边都链接这一行的第一个名称表示的顶点和其他名称表示的顶点
+ 顶点总数和边总数是未知的
### 4.1.7.1 API
            用符号作为顶点名的图的API
        public          class           SymbolGraph
                                        SymbolGraph(String fileName,String delim)
                        boolean         contains(String key)
                        int             index(String key)
                        String          name(int v)   
                        Graph           G()
### 4.1.7.2 测试
### 4.1.7.3 实现
完整实现需要以下三种数据结构
+ 一个符号表st，键为String，值为int
+ 一个数组keys[],反向索引，保存每个顶点对应的顶点名
+ 一个图对象
### 4.1.7.4 间隔的度数
图处理的另一个经典问题，就是，找到一个网络中两个人之间间隔的度数。比如一个游戏，演员影视图，
kevin本人为0，所有和他一起出演同一部电影的人的值为1，所有和值为1的人（除kevin）演过同一部
的其他演员的值为2，以此类推。
# 总结
几个基本概念
+ 图的术语
+ 图的数据结构表示，处理稀疏且大型的图
+ 和图处理相关的类的API
+ 深度优先和广度优先
+ 支持使用符号作为图的顶点



                        
            


       
          





  
        


