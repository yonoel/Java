#  最短路径（MST。。）
加权有向图。

定义，在一幅加权有向图，从s到t的最短路径是s到t的路径中权值最小者。

讨论以下问题：
+ 加权有向图的API以及单点最短路径的API
+ 解决边的权值非负的最短路径 Dijkstra 算法
+ 在无环加权有向图中解决该问题的一种快速算法，权值可为负
+ 适用于一般情况的 Bellman-Ford 算法，图可以有环，权值可以为负。
还需要算法找出负权值的环，以及不含有这种环的图里的最短路径。
## 4.4.1 最短路径的性质
+ 路径是有向的
+ 权值不一定代表距离
+ 并不是所有顶点可达
+ 负值会使问题复杂
+ 最短路径一般都是简单的
+ 最短路径不一定唯一
+ 可能存在平行边和自环

最短路径树（SPT）

定义，给定一幅加权有向图和顶点S ， 以s为起点的一棵最短路径树是图的一幅子图。
它包含S以及S可达的所有顶点。这棵树的根为S，树中的每条路径都是有向图中的一条最短路径。

## 4.4.2 加权有向图的数据结构（DST）
### 4.4.2.1 最短路径的API
### 4.4.2.2 测试
### 4.4.2.3 最短路径的数据结构
+ 最短路径树中的边（边数组）EdgeTo
+ 到达起点的距离 DistTo
### 4.4.2.4 边的松弛
最短路径的API实现基于relaxation操作。一开始我们只知道边，以及权值，distTo中
只有起点对于的元素值为0，其余均为正无穷，随着算法的执行，把最短路径的信息存入两个数组
，遇到新边时，就可以更新这两个数组。

relax定义如下，放松v->w 这条边意味检查s至w的最短路径是否是从s到v，在从v到w，如果是
，更新数据结构。
### 4.4.2.5 顶点的松弛
实际上，会松弛顶点所有边
### 4.4.2.6 为用例准备查询方法
支持pathTo和hasPathTo，distTo的查询。has可以根据distTo是否正无穷，path根据edgeTo数组
## 4.4.3 最短路径的理论基础
最根本在于松弛，遍历了顶点的所有链接边，研究好这个就能证明最短路径
### 4.4.3.1 最优性条件
证明 判断路径是否为最短路径的全局条件 是否和 松弛 一条边所检测的局部条件 等价

命题P （最短路径的最优性条件） G为加权有向图，s是起点，distTo是顶点索引的数组，保存G
中的路径长度，对于s可达的所有顶点v，distTo[v]为s到v的距离，不可达的距离为正无穷。
当且仅当 对于v到w的任意一条边 e ，这些值都满足 distTo[w] <= distTo[v] + e.weight()时，这就是最短路径的权值。

证明 假设distTo[w]是s到w的最短路径，如果某条从v到w的边e使得distTo[w] > distTo[v] + e.weight
，那么s到w（并且经过v，经过e）的路径更短，distTo[w]不是最短路径。因此这个等式 是必要条件。
证明是充分条件，假设w是从s可达的，且s = v0-v1....vn =w 是最短路径，且权值为OPT 对于
1到k直接的i，令ei表示vi的边。首先根据之前必要条件可以推到以下不等式：
    
    ```
        distTo[w] = distTo[Vk] <= distTo[Vk-1] + ek.weight
                    distTo[Vk-1] <= distTo[Vk-2] + ek-1.weight
                    ....
                    distTo[V2] <= distTo[V1] + e2.weight
                    distTo[V1] <= distTo[s] + e1.weight
    ```
综合这些不等式，可得 
distTo[w] <=  ek.weight + ek-1.weight+.....+e1.weight = OPT

现在distTo[w]是s到w的某条边的长度，因此它不可能比opt更小，因此 opt<= distTo[w]
### 4.4.3.2 验证
验证最短路径的权值
### 4.4.3.3 通用算法
命题Q 将distTo[s]设为0 ，其他为无穷大，松弛图的任意边，直到不存在有效边为止。
对于任意可达的顶点w，在进行这些操作后，便得到了最短路径。

证明。。。见Q

将最优性条件和通用算法放一起的原因是，通用算法没有指定边的放松顺序，因此要证明它能做到最短路径，只需证明它会松弛所有边直到失效。
## 4.4.4 Dijkstra算法
MST里prim算法，每一步只加一条比新的边，此算法用类似的方法来计算最短路径树。之前通用里
是遍历里所有的链接顶点，这个在distTo里最小的非树顶点放松加入树中，直到顶点都在树里，或者非树顶点的值都为无穷大。

命题R 此算法能解决问题。

证明，如果v是s可达的，那么v-w的边只会被放松一次，当v放松时，必然有distTo[w] <= distTo[v] + e.weight,注意等式，distTo[v]是不变的。因此在所有s可达的顶点进入树以后，最短路径就以及求出来了。

### 4.4.4.1 数据结构
类似prim在加一个优先队列。。。
### 4.4.4.2 换一个角度思考
看图说话

命题R 此算法所需空间与V成正比 时间与ElgV成正比

证明 同prim

思考，参照prim算法一起思考，prim是每次添加的是权值最小的非树顶点，Dijkstra
每次添加是离起点 权值最小的非树顶点。
### 4.4.4.3 变种
对此算法进行改进就能得到其他解法。比如无向图的最短路径。

给定两点的最短路径，优先队列找到终点时就结束。

任意顶点对直接的最短路径。

欧拉图中的最短路径。
## 4.4.5 无环加权有向图中的最短路径
见AcyclicSP

比Dijkstra算法更快，特点
+ 能够在线性时间解决
+ 能够解决负数权值
+ 能够解决相关问题，最长路径
都是在拓扑排序的基础上拓展的。

比如，将松弛和拓扑排序结合，就能得到一种解法，解决无环的最短路径。按照拓扑排序松弛顶点即可。

命题s 按照拓扑排序松弛顶点，就能在E+V的时间内解决无环加权有向图的SP

证明 边v->w只会松弛一次，得到distTo[w] <= distTo[v]+e.weight.
在算法结束前该不等式都成立，因为distTo[v]不变，而dist[w]只会变小，因此
在所有从s可达的顶点加入树后，SP就成立了，命题Q也成立了，时间上限是因为
命题，拓扑排序所需时间为 E+V 而第二次遍历，每条边又只会被一次，因此与E+V成正比

基于拓扑排序的方法比Dijksta快的倍数与Di算法中优先队列的操作总承包成正比。
另外S证明和边的权值是否为负数无关。

### 4.4.5.1 最长路径
考虑无环加权有向图最长路径时，边的权值可以为负数。

命题T ， 解决这个问题的时间与E+V成正比。

证明，给定一张图，复制此图，并且将权值为负数，那么，此图的副本中最短路径即是原图的最长路径。
（当然也可以把distTo的值设为负无穷，并且relax改变不等式方向）

见AcyclicLP
### 4.4.5.2 平行任务调度问题
这次解决的问题和之前有所不同
+ 优先级限制下的并行任务

4.2拓扑排序处理的是，单个处理器，单线程，现在可以多线程。

一种线性时间的算法，"关键路径"的方法证明这个问题和无环加权有向图中的最长路径是等价的。

定义 解决并行任务调度问题的关键路径方法步骤如下
+ 创建一幅加权无环有向图 ，其中包含起点s，终点t，每个任务对应两个顶点（开始和结束顶点（路径？））
+ 对于每个任务都有一条从它的起点到结束顶点的边，边的权值为时间
+ 对于每条有优先级限制的v->w，我们添加一条从v到w的且权值为0的边
+ 为每个任务添加一条从起点指向该任务结束顶点的权值为0的边，以及一条从该任务的结束顶点到终点的权值为0的边
+ 每个任务预计的开始时间即为从起点到它的起始顶点的最长距离

// 443 要回来拍照

图中每个任务对应三条边（1.起点到任务起始顶点，2.结束顶点到终点且权值为0，3.从起始到结束顶点），
优先限制条件又对应着一条边

关键路径，将问题归约为寻找最长路径

命题U 关键路径法所需的时间为线性级别
+ 首先，在图里，每条路径都有任务起点和终点组成的并由权值为0的限制条件的边隔离。
+ 从起点到终点的任意顶点v的路径长度都是v的开始和结束时间的实现，而且这还是一个线程运行这个任务的可能性，因此单个顶点最短路径必定是最优解。
+ 因此从s到t的最长路径就是所有任务的完成时间的下限（最短时间）
+ 由最长路径得到的开始和结束时间都是可行的，因为每个任务都被限制条件所隔离
+ 因此s到t的最长路径就是完成所有任务的上限

### 4.4.5.3 相对最后期限限制下的并行任务调度
一般的最后期限是相对于 第一个任务的开始时间而言。假设在任务调度中，加入一种新的限制，需要某个任务
在指定的时间点之前开始，即指定此任务和另一个任务的开始时间的相对时间。

最后期限的限制越多，调度的可能性越低，简单问题也会复杂。

命题V 相对最后期限限制下的并行任务调度问题是一个最短路径问题

证明，同U ， 为每个限制条件加权值为-d的边。。。本来是0，现在加上去？

## 4.4.6 一般加权有向图中的最短路径问题
考虑 可能有环，还可能有负权值；最明显的改变就是有负数，我们可能会多走一些边
### 4.4.6.1 尝试1
先找到权值最小的边，然后把所有权值都加上这个负数的绝对值，因此权值没有负数了。
完全没有乱用。
### 4.4.6.2 尝试2
改造Dijkstra算法，不成立，因为命题R的假设条件之一就是添加一条边会使
路径变长，但是负值添加一边变短。。/
### 4.4.6.3 负权值的环
如果图中有负数环，那么最短路径就没有意义了。。。因为绕着他就能得到负数，而且
不是环的所有边权值为负就有用，环的权重之和为负数即可。

定义 负权重环是一个总权重为负的有向环

如果有这样的环，不存在最短路径。
### 4.4.6.4 尝试3
指数级别，过于复杂，不研究。因此只研究简单版本。
因此，定义明确且可以解决加权有向图最短路径问题算法要能够
+ 对于起点不可达的顶点，最短路径为正无穷
+ 对于起点可达但路上存在负权重环的顶点，最短路径为负无穷
+ 对于其他顶点，计算最短路径但权重以及最短路径树

首先我们放宽条件，并依次解决这些问题：
+ 负权重环的检测
+ 负权重环不可达的顶点的最短路径

总结， 在含有环的有向图里问最短路径是没有意义的，而且无法有效解决这种有向图高效的算法，但实际中仍需要检测负权重环。

命题X bellman-ford算法：将distTo[s]初始化为0，其他元素无穷大，以任意顺序松弛有向图的所有边，重复V轮

证明，对于s可达的任意顶点t，都有一条最短路径v0-v1-v2。。。vk，其中起点为s，终点是t。
因为负权重环是不可达的，因此，这样的路径是存在的，且k不会大于v-1。假设对于i成立，那么
s到i的最短路径就是v1-v2-v3。。。vi，distTo[Vi]就是它的路径长度，我们放松i轮里
所有顶点，因此distTo[Vi+1] 必定小于等于 distTo[Vi]+ Vi+1 .weight。它不可能更大
，也不可能更小，因为这就是最短路径。因此在i+1轮松弛后可得到s到Vi+1的最短路径。  

命题w，此算法所需时间和EV成正比，空间和V成正比。

证明，在每一轮中都放松E条边，并重复轮V轮
```
    for ( pass = 0 ;pass < V;pass++ ){
        for ( v=s;v<V;v++   ){
            for (Edge e: g.adj(v)){
                relax(e)
            }
        }
    }
```
### 4.4.6.5 基于队列的Bellman-Ford算法
很明显，任意一轮中的松弛有些是不会成功的，只有上一轮distTo值发生变化了的顶点所出发的边，才能改变其他
顶点distTo的值，为了记录这样的顶点，我们使用优先队列FIFO。

### 4.4.6.6 实现
要保证算法的实现，就要保证V轮后算法终止，或者去检测负权重环。

命题y 此算法最坏情况时间与EV成正比，空间与V成正比

证明，如果不存在负权重，会根据命题X在V-1轮后终止，如果存在负权重环，队列永远不可能为空。
最坏情况，此算法和通用算法一样，也要全部遍历。

### 4.4.6.7 负权重的边
### 4.4.6.8 负权重的环检测
### 4.4.6.9 套汇
顶点对应货币，边对应汇率，权重为x表示边s->t的汇率是x。因此s->t->u，意味一单位的s
兑换成xy个u。因此找到图中权重之乘积最大的理论上利润最大。还有一种情况就是，
所有边的权重乘积小于从终点指向起点的权重，假设u->s权重为xyz>1，那么s->t->u->s
的一个单位的s可换来多于一个单位的s，可以得到（xyz-1）的利润。

命题Z 套汇问题等价于加权有向图中的负权重环检测问题

证明 取权重的自然对数取反，这样原始问题的所有边之乘积就变成了新图中所有边的权重之和的计算。
# 展望
                    最短路径算法的性能特点
                    
    算法              局限          一般情况   最坏情况         所需空间        优势
    Dijkstra        权重必须为正      ElogV   ElogV              V        最坏情况下也有最佳性能
    拓扑排序     只适用于无环加权有向图  E+V      E+V               V        无环图中的最优算法
    Bellman-Ford    不能存在负权重环  E+V       VE                V         适用场景多
    
Dijkstra与生成最小生成树的prim类似
    













 







