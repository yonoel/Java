# 最小生成树（加权图）
加权图是一种为每条边关联一个权值或是成本的图模型。比如航空图，边表示路线，权值是距离或者费用。

最小生成树： 给定一幅加权无向图，找到它的一棵最小生成树（最小成本化）

定义，图的生成树是它的一棵含有其他所有顶点的无环连通子图。一幅加权无向图的最小生成树（MST）是它的一棵权值最小的生成树。

prim算法和krusal算法

约定：
+ 只考虑连通图，否则就是最小生成森林了。
+ 边的权值不一定代表距离
+ 边的权值可能是0也可能是负数
+ 所有边的权值各不相同（否则可以不唯一）
## 4.3.1 原理
树的两个最重要性质（根节点没有前驱节点，只有后继节点）
+ 用一条新边链接树中任意两个顶点会产生一个新的环
+ 从树中删去一边会得到两棵独立的树
### 4.3.1.1 切分定理
定义， 图的一种切分是将图的所有顶点分为两个非空且不重复的两个集合（两个树）。横切边是链接两个不同顶点的集合（树）的边

通常，我们指定一个顶点集，并认为它的补集为另一个顶点集，来指定一个切分。这样横切边就是链接该集合的一个顶点和补集的一个顶点的边。

命题j，在一幅加权图中，给定任意的切分，它的横切边中的权值最小值必然是图的最小生成树。

证明，反证假设MST里不包含最小横切边E，那么如果将E加入MST，得到一个环，且这个环必定至少含有另一条边F，F的权值必然大于E，那么我们删除F，得到的树必然比MST的权值更小，矛盾。
### 4.3.1.2 贪心算法
切分定理是找到最小生成树的算法的基础，而这个算法是贪心算法的特殊情况：使用切分定理找到这条边，不断重复直到找到最小树的所有边。

命题K（最小生成树的贪心算法）将含有V个顶点的加权图中属于MST的边标记为黑色，初始状态都为灰色。直到标记了V-1条边。

## 4.3.2 加权无向图的数据类型
有三种选择
+ 链接矩阵。V*V的矩阵用权值表示
+ 边的数组。使用一个Edge类，简洁，但是无法快，实现adj时要检查所有的边。。和顶点
+ 链接表数组。使用一个以顶点为索引的列表数组（增加一个权重值），其中每个元素都是和该顶点相邻的顶点列表（hash表啊！）
            
                        加权边的API
        public          class       Edge        implements Comparable<Edge>
                                    Edge(int v, int e, double weight)
                        double      weight() 权值
                        int         either()
                        int         other(int v)
                        int         compareTo(Edge that)
                       
                       
                       加权无向图的API
        public         class        EdgeWeightedGraph
                       int          V()
                       int          E()
                       void         addEdge(Edge e)
                                    adj(int v)
                                    edges()
                                                        
### 4.3.2.1 用权重比来比较边
### 4.3.2.2 平行边
### 4.3.2.3 自环
允许存在。但是当前实现没有统计。使用edge类干净整洁，但是冗余信息也多。另一种用法是与graph一样，用两个节点对象来表示一条边，每个节点对象保存顶点信息和边权值，这个方法也有代价---需要两个节点，权值会被保存两次。
## 4.3.3 MST的API和测试用例
我们有以下几种表示MST的数据结构可选择
+ 一组边的列表（最方便）
+ 一幅无向图
+ 一个以顶点为索引且含有父节点链接的数组
### 4.3.3.1 测试
### 4.3.3.2 测试数据
## 4.3.4 prim算法
此算法每一步都为一棵生长中的树加一条边，一开始只有一个顶点，每次总是将下一条链接树中的顶点与不在树中的顶点且权值最小的边 加入树。
1. 先随便定义个顶点
2. 找链接，且不在树里的顶点，且权值最低的边连城树
3. 重复上面的操作
### 4.3.4.1 数据结构
+ 顶点，数组如果顶点在树中，为true
+ 边（MST的边），1.一条队列mst保存所有边，2.由顶点索引的edge数组
+ 横切边（所有边）：横切顶点的边，优先队列MinPQ
### 4.3.4.2 维护横切边的集合
见图（这是普通版实现）
### 4.3.4.3 实现
lazy实现
### 4.3.4.4 运行时间
命题M prim算法的延时实现计算含有V个顶点和E条边的连通加权无向图的MST所需空间与E成正比，时间与ElgE成正比

证明，算法瓶颈在insert和delmin上，最坏情况，insert成本是～lg，删除为～2lgE
## 4.3.5 Prim算法的即时实现
改进lazy版，在pq里直接删除无效的边--》不需要保存所有边，只保存非树内顶点的最小边。用edgeTo和distTo
替代marked和mst，具有以下性质
+ 如果顶点V不在树中，但至少有一条边与树相连，那么edgeTo[V]是这条最短边，distTo[v]是这条边的权值
+ 所有这类顶点都保存在一个优先队列里，索引v关联的值是edgeTo

这些性质的关键在于优先队列中最小的键即时最小横切边的权值，而和他关联的顶点就是下一个mst里的顶点，marked已经么有必要。
因为判断 ！marked等价于distTo是否无穷且edgeTo为空。

两者在时间上限没有区别，但是空间上限有了进一步的区别。

命题N prim算法的即时实现计算一幅含有V个顶点和E条边的连通加权无向图的MST所需空间和V成正比，时间与ElogV成正比

证明，因为优先队列中边树最多为V ，且使用了三条由顶点索引的数组，所以所需空间上限和V成正比，算法进行
V次插入和删除，最坏情况E次比较。大多数情况，树的生长通过链接一个和新加入的顶点相链接的顶点。当新加入的顶点周围
没有非树顶点时，树的生长又会从树的另一部分开始。

## 4.3.6 Kruskal 算法
主要思想是，按照边的权值顺序处理。依次将最小权值边加入，且不能形成环。

命题O Kruskal算法能够计算任意加权无向图的最小生成树。

证明 由K可知，如果下一条将被加入的边不会构成环，那么它就不是。。。。的补集。。。

命题N 此算法计算MST所需空间和E成正比，时间与ElogE成正比

实际上，成本与 E + E0 logE 成正比，E0是MST内权值最大的边的所有边的总数，一般这个算法比prim慢，因为处理边时还需要进行connect操作。
## 展望
### 4.3.7.1 历史资料
                各种MST算法的性能特点
        算法              空间              时间
        延时Prim          E               ElgE
        即时Prim          V               ElgV
        Kruskal          E               ElgE
        Fredman-Tarjan   V              E+VlgV
        Chazelle         V              非常接近但还没有达到E
        理想情况          V                 E？
### 4.3.7.2 线性的MST算法
        
        






