# 1.5 案例研究:union-find
## 1.5.1 动态连通性
问题：输入是一列整数对，每个整数都表示一个某种类型的对象，一对整数pq可以理解为"pq相连"

假设相连是一种对等关系，这也就意味着
+ 自反性
+ 对称性
+ 传递性
如果不是整数对，打印出来
### 1.5.1.1 网络
### 1.5.1.2 变量名等价性
### 1.5.1.3 数学集合
将整数称为触点，将整数对称为连接，将等价类称为连通分量，简称分量

假设有0到N-1的整数表示N个触点
### 1.5.1.1 网络
## 1.5.2 实现
3种不同实现
### 1.5.2.1 quick-find算法
保证当且仅当id[p] = id[q]时,p和q是连通的，即在一个连通分量里，所有的触点在id[]中的值是相同的。

为了调用union(p,q)，首先检查是否以及存在于一个连通分量里，如果不存在，需要将p所在的分量中所有触点的id[]值均为同一个值，q累死，并且这两个分量需要
归一。详见tinyUF
### 1.5.2.2 quick-find算法分析
find很快，union太慢，每次都要遍历数组全部

命题：在此算法中，find访问一次数组，而union访问数组的次数在
(N+3)(2N+1)之间

证明：union时，调用两次find,并检查数组里的全部N个元素并改变1到N-1

假设我们用此方法来解决动态连通问题，并最终得到一个连通分量，至少调用N-1次union
即至少(N+3)(N-1)~N^2次数组访问

### 1.5.2.3 quick-union 算法
union应当于find方法形成互补，而不是累赘，它以基于相同的数据结构--以触点作为索引的数组，但我们需要赋予它不同的意义。

每个触点所对应的id是一个分量中另一个触点的名称（也可能是其自身），我们将这种联系称为链接。在实现find时，我们从给定触点开始
由此链接到另一个触点，以此类推，直到根触点，即指向自己，当且仅当分别由两个触点开始并到达了一个根触点时，认为他们在一个分量里
### 1.5.2.4 森林的表示
用节点便是触点，用一个节点指向另一个节点的箭头表示链接，也就是树形结构
### 1.5.2.5 quick-union 算法分析
分析这种结构比分析简单的链表结构更困难，因为这依赖输入，最好情况，访问一次数组就能找到根节点，而最坏需要2N-1次；最佳情况是
线性级别，最坏情况是平方级别。现在的问题就是不能保证所有情况下它能比quick-find更快

定义：一棵树的大小是它的节点的数量。树中的一个节点的深度就是它到根节点的路径上的链接树。
树的高度就是它所有节点中的最大深度。

命题G：此find方法访问数组的次数为1加上给定触点所对应的节点的深度的两部。union和connected访问数组的次数为
两次find（如果union中的两个节点不在同一棵树，在加1）

如果数组是有序的，那么树的高度为N-1。union操作次数为2i+2，处理所有N对的总次数为2（1+2+。。。）～N^2

### 1.5.2.6 加权 quick-union 算法
与其在union中随意将一棵树链接到另一棵树，不如记录下树的大小，把小树连接到大树

加入一个数组来记录树的大小
### 1.5.2.7 加权 quick-union 分析
其中将要被归并的树总是相等的，且总是2的幂次方，均含有2^n个节点，高度为n

归并两个2^n的树时，新的树的高度就是2^n+1,高度为n+1，由此保证此算法的性能在对数级别

命题：对于N个触点，加权的算法使任意节点的深度最多为lgN

证明:森林中为k的树的高度为lgk,在原始情况，高度为0，k=1；
假设高度为i的树，高度最大为lgi,并且i<=k,且i+j=k
1+lgi=lg(i+i) <= lg(i+j)=lgk

推论，最坏情况下增长级别为lgN

### 1.5.2.8 最优解法
大家选择了修改加权算法，每个节点都指向根节点，也就是路径压缩的加权quick-union
### 1.5.2.9 均摊成本的图像
## 1.5.3 展望
## Q&A






