#1.4 算法分析
## 1.4.1 科学方法
再多的实验也不一定能够证明我是对的，但只需要一个实验就能证明我是错但
## 1.4.2 观察
第一个定量观察就是计算性任务但困难程度：问题的规模
### 1.4.2.1 举例
ThreeSum
### 1.4.2.2 计时器
### 1.4.2.3 实验数据的分析
程序在不同计算机上的运行时间之比是个常数

x轴表示N（问题规），y轴表示时间T（N）
a为常数

lg(T(N)) = 3 lgN+lg a

很明显，这个公式等价于T(N)=aN^3

对数图中的直线等价于对于T(N)=aN^b的猜想，这种公式被成为幂次法则

## 1.4.3 数学模型
一个程序运行的总时间主要和两点有关
1. 执行每条语句的耗时
2. 执行每条语句的频率
### 1.4.3.1 近似
 if语句的执行次数
 
 N*（N-1）(N-2)/6 = (N^3) /6 - (N^2)/2 + N/3
 
 显而易见，当N很大时，只有首项有意义
 定义：
    我们用~f(N)表示随着N增大除以f(N)的结果趋于1的函数；
    用g(N)~f(N)表示g(N)f(N)随着N增大趋近于1
    
常见的增长数量级函数

     描述             函数
     常数级别           1
     对数级别           logN
     线性级别           N
     线性对数级别        NlogN
     平方级别           N^2
     立方级别           N^3
     指数级别           2^N
### 1.4.3.2 近似运行时间
### 1.4.3.3 对增长数量级的猜想
性质A： ThreeSum 的运行时间增长数量级为N^3
### 1.4.3.4 算法的分析
### 1.4.3.5 成本模型
3-sum的成本模型是访问数组的次数

目前的暴力算法使用了~(N^3)/2次访问数组
### 1.4.3.6 总结
对于大多数程序，得到运行时间的数学模型需如下步骤
1. 确定输入模型，定义问题规模
2. 识别内循环
3. 根据内循环中的操作确定成本模型
4. 对于给定的输入，判断执行频率

如果一个程序含有多个方法，分别讨论

二分查找。输入是大小为N的数组，内循环是while语句内的所有语句
成本模型是比较操作（比较两个元素的大小），比较次数最多为lgN+1

白名单。输入是大小为N的白名单和标准输入的M个整数，且M>>N
内循环也是while语句，成本模型也是比较操作（承自二分查找），比较次数为M(lgN+1)

因此白名单的增长数量级别近似为MlgN：
 + 如果N很小，那么M，N（输入和输出）都是主要成本，
 + 比较次数的取决于输入M 在～M和~M(lgN)之间
 + 假设排序的成本<<MlgN
 
                    常见函数
        描述             记号           定义
        向下取整floor     [x]
        向上取整ceiling
        自然对数          lnN            loge(N) e^x = N
        以2为底的对数      lgN            log2(N) 2^x = N
        以2为底的整形对数
        调和级数           Hn            1 + 1/2 + 1/3 + .... 1/N
        阶乘              N!            1*2*3*4*。。。。*N
                    常用的近似函数
        调和级数求和      Hn = 1 + 1/2 + 1/3 + .... + 1/N ~lnN
        等差数列求和      ~ (N^2)/2
        等比数列求和      1+2+4+8+。。。。+N=2N-1 ~2N,其中N=2^n
        斯特灵公式       lgN! = lg1+lg2+....+lgN ~ NlgN
        二项式系数       
        指数函数         (1-1/x)^x ~1/e
## 1.4.4 增长数量级的分类
            对增长数量级的常见假设的总结
        描述          增长的数量级别         典型的代码           说明       举例
      常数级别              1              a = b + c        普通语句            
      对数级别           log N              二分查找         二分策略       二分查找
      线性级别             N              for ()             循环
      线性对数级别        N log N                             分治        归并排序
      平方级别           N ^ 2            for( for( ))      双层循环      检查所有元素对
      立方级别                                              三层循环
      指数级别              2^ N                            穷举查找       检查所有子集
### 1.4.4.1 常数级别
### 1.4.4.2 对数级别
### 1.4.4.3 线性级别
### 1.4.4.4 线性对数级别
### 1.4.4.5 平方级别
### 1.4.4.6 立方级别
### 1.4.4.7 指数级别
## 1.4.5 设计更快的算法
解决3-sum
### 1.4.5.1 热身2-sum
假设2个求和，那么只要存在第二个数为-n，即存在
+ 如果二分查找返回-1，不增加
+ 如果返回的j>i，即存在a[j]+a[i] = 0
+ 如果返回的j<i，不增加
那么算法的增长级别为NlogN
### 1.4.5.2 3-sum的快速算法
当且仅当 -(a[i]+a[j])在数组中时，存在结果，算法的级别就变成了N^2logN
### 1.4.5.3 下界
对于2-sum，没有，成本模型仅允许使用并计算这些数的线性或者平方级别的函数

对于3-sum，不知道
## 1.4.6 倍率实验
+ 开发一个输入生成器来产生实际情况中的输入DoublingTest
+ 计算本次和上次的时间比值DoublingRatio
+ 反复运行知道比值接近于极限 2^b
这个方法对于比值没有极限的算法无效，但得出以下结论
+ 运行时间但增长级别为N^b
+ 要预测一个程序，将上次的时间*2^b并将N加倍

命题C 倍率定力，如果T(N) ~aN^blg N 那么 T(2N) / T(N)  ~2^b

在有性能压力的情况下应考虑倍率实验，估计运行时间
### 1.4.6.1 评估它解决大型问题的可行性
### 1.4.6.2 评估大型计算机的所产生的价值
很明显指数级别的没有意义
## 1.4.7 注意事项
### 1.4.7.1 大常数
### 1.4.7.2 非决定性的内循环
### 1.4.7.3 指令时间
缓存技术
### 1.4.7.4 系统因素
### 1.4.7.5 不分伯仲
### 1.4.7.6 对输入的强烈依赖
假设运行时间和输入无关，比如3-sum询问的是是否存在，那就强烈依赖于输入
### 1.4.7.7 多个问题参量
## 1.4.8 处理对于输入的依赖
### 1.4.8.1 输入模型
### 1.4.8.2 对最坏情况的性能保证
### 1.4.8.3 随机化算法
### 1.4.8.4 操作序列
### 1.4.8.5 均摊分析
提供性能保证的另一种方法是通过记录所有操作的总成本除以操作数，均摊成本

典型例子就是 动态调整数组大小的stack结构，假设N是2的幂次方，假设第一次为空
N次调用push方法，数组访问的次数是

N + 4 + 8 + .....+2N = 5N - 4

其中首项表示N次push调用，其余表示每次数组加倍初始化数据结构所访问的数组次数 
因此每次操作访问数组的平均次数是常数，但最后一次是线性
我们将少量昂贵的操作通过大量的廉价操作摊平了
## 1.4.9 内存
### 1.4.9.1 对象
要知道一个对象所使用的内存了，需要将所有实例变量使用的内存与对象本身的开销相加

这些开销包括 一个指向对象的类的引用，垃圾收集信息，同步信息

比如
+ 一个Integer对象使用24字节（16字节的对象，4字节保存int，4个填充）
+ 一个Date对象，32字节，16字节对象，3个int变量12字节，4个填充

对象的引用一般都是一个内存地址，8字节

+ 一个counter对象，32字节16字节对象，8字节String，4int，4填充
### 1.4.9.2 链表
### 1.4.9.3 数组
### 1.4.9.4 字符串对象
40
### 1.4.9.5 字符串的值和子字符串
重用value数组
## 1.4.10 展望

# Q&A
提高题没做










      
       
      
                

 
 

