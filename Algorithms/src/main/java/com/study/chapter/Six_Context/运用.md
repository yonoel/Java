# 1.事件驱动模式 Event Driven pattern
按照弹性碰撞的原理模拟粒子系统的运动
### 6.0.1.1 球体模型
+ 运动的粒子和墙相互之间的碰撞是弹性的
+ 每个粒子都是一个已知位置，速度，质量，直径的球体
+ 不存在其他外力
### 6.0.1.2 时间驱动模拟
目标是维持这个模型，即希望能够记录所有粒子在任意时间内的位置和速度。
需要计算在给定的t时刻，所有粒子的位置和速度，再给出dt时间，即未来的时间点
t+dt时它们的位置和速度。

时间驱动模拟，基于使用定长dt，每次更新时，检查所有粒子，判定是否可能相遇，
还原第一次碰撞。此时我们更新两个粒子的速度和碰撞结果。

当粒子很多时，这种方式的计算量非常大：如果dt是以秒计，模拟的N个粒子一秒钟的运动
所需时间与 N^2 / dt 成正比。问题就在于，如果dt太小，计算量太大，dt太大，可能错过碰撞。
### 6.0.1.3 事件驱动模拟
重点关注下一次碰撞，使用优先队列记录所有事件。事件是未来的某个时间的一次
潜在的碰撞。和每个事件关联的优先级就是发生的时间，因此这个优先队列
每次删去优先级最低的元素，即得到了下一次的碰撞
### 6.0.1.4 碰撞预测
假设，在时刻t有一个半径为s，速度为（Vx，Vy）的粒子位于（Rx，Ry）。
假设墙位于x=1处，高度y在0到1之间。我们最终需要的是运动的横向分量，
因此集中在x 分量Rx和速度的x 分量Vx上。 
如果Vx是负数，那么粒子就不会与墙相撞。如果是正数，就存在潜在碰撞，
粒子和墙的距离 （1 - s - Rx） 除以速度分量  Vx 得到了碰撞时间 dt;
即dt后 粒子的位置在  (1-s,Ry+Vy*dt)。

因此可以向优先队列插入一个优先级为 t + dt 的元素（描述该碰撞，以及碰撞事件的信息）。
### 6.0.1.5 碰撞计算
如果发生碰撞，粒子速度从（Vx，Vy）变为（-Vx，Vy）。
### 6.0.1.6 排除无效事件
预测的许多碰撞不会实际发生，因为被其他碰撞所打断。为了处理这种情况，我们为
每个粒子维护一个对象变量来记录和它有关的碰撞数量。
当从优先队列里取出一个事件处理时，检查该事件涉及的粒子碰撞计数器在事件创建
后是否更新。

这是排除无效碰撞的延时方法：当某个粒子参与了一次碰撞，我们不删除队列中和该粒子
有关的其他碰撞（尽管这些碰撞已经无效），而是在之后遇见这些碰撞时忽略其碰撞。

即时的方式：立刻从优先队列中删除所有与参与当前事件的粒子相关的其他事件，然后在重新计算新的碰撞事件。
### 6.0.1.7 粒子
### 6.0.1.8 事件
Event 的实现能表示这四种类型的事件，允许粒子为空：
+ a 和 b 均不为空， 碰撞。
+ a 非空 b空 ，粒子a与垂直墙体碰撞
+ a 空 b非空，粒子b与水平墙体碰撞
+ a，b均空，重绘事件

event的第二个技巧是，它维护了两个实例变量countA和count，以记录事件创建
时每个粒子参与的碰撞事件数量。如果event发生时，该值没有变化，那么就能模拟
事件发生，如果变化了，事件失效。
### 6.0.1.9 模拟器代码
### 6.0.1.10 性能分析
命题A 对N个能够互相碰撞的粒子系统，基于事件驱动的在初始化时最多需要 N^2 次优先队列
操作，在碰撞时需要 N次优先队列操作。
# 2.B- 树
但是咱们有面对这样一个实际问题：就是大规模数据存储中，实现索引查询这样一个实际背景下，树节点存储的元素数量是有限的（如果元素数量非常多的话，查找就退化成节点内部的线性查找了），这样导致二叉查找树结构由于树的深度过大而造成磁盘I/O读写过于频繁，进而导致查询效率低下（为什么会出现这种情况，待会在外部存储器-磁盘中有所解释），那么如何减少树的深度（当然是不能减少查询的数据量），一个基本的想法就是：采用多叉树结构（由于树节点元素数量是有限的，自然该节点的子树数量也就是有限的）。




 B-树 支持对保存在磁盘或者网络上的符号表进行外部查找，这些文件比我们以前考虑的输入大很多（以前的输入能保存在内存中）。 
### 6.0.2.1 成本模型
用页表示一块连续的数据，用探查表示访问一个页。假设访问一页需要将其内容保存进本地内存，一页可能是
网上一页也可能是文件。
  
 使用页的访问次数 作为 外部查找算法的成本模型
### 6.0.2.2 B- 树
是红黑树的拓展，关键的不同在于，我们不会将数据保存在树中，而是会构造一棵
由键的副本组成的树，每个副本关联着一条链接。

限制每个节点中能够含有的 "键-链接"对 的上下数量界限：选择一个参数M 并构造
一棵多向树，每个节点含有M-1 对 键-链接，最少含有 M /2 对 键-链接。
根节点是例外，它可以含有少于 M/2 对 键-链接，但也不能少于 2对。用 B- 树泛指
所有基于固定页大小的多向平衡查找树的数据结构。

我们用M 阶 的B- 树来指定 M的值。在一棵 4阶B-树中，每个节点至少有2对
至多3对 键-值对 。6阶 则是 最少 3 最多 5 
### 6.0.2.3 约定
对于 B- 树，我们使用以下不同类型的节点：
+ 内部节点，含有与页相关联的键的副本
+ 外部节点，含有指向实际数据的引用

内部节点中每个键都与一个节点关联，以此节点为根的子树中，所有的键
都大于等于此节点关联的键，但小于原内部节点中更大但键（如果存在）。
为了方便，这里使用了一个 哨兵 键 ，符号表不含有 重复键，但我们在 （内部节点）
  中使用 键的 多个副本 来引导查找。
### 6.0.2.4 查找和插入
查找的基础是在可能含有 被查找键的 唯一子树中 进行递归搜索。当且仅当存在时，查找结束
于一个外部节点。 在内部接种遇见查找键的副本时，就判定查找命中并结束，但总会找到相应的外部节点。
因为这么做可以简化将 B- 树扩展为有序符号表的实现。 

定义 一棵M 阶B- 树（M为正偶数）或者仅是 一个外部 k- 节点 （含有k个键和相关信息的树），
或者由若干内部 k- 节点 （每个节点含有k个键和k条链接，链接指向的子树表示了键之间的间隔区域）组成。
它的结构性质若下：从根节点到每个外部节点的路径长度相同（完美平衡），对于根节点，k在2到m-1之间，对于其他节点k在M/2到M-1之间。
### 6.0.2.5 数据表示
见Page

接受Page对象作为参数并处理以下情况
+ 如果当前页是外部页且键在该页中，返回true
+ 如果当前页是外部页且键不在该页中，返回false
+ 否则，递归查找
### 6.0.2.6 性能
最重要的性质，在实际应用中对于适当的参数 M ，查找的成本是常数级别

命题 B 。含有 N个元素的M 阶B- 树的一次查找或插入操作需要 lgmN ~ lgm/2 N 次查找
### 6.0.2.7 空间需求
见BTreeSET 

在实际中，页的构造可知，几乎半满。

# 3.后缀数组(字符串)
### 6.0.3.1 最长重复子字符串
### 6.0.3.2 暴力解法
### 6.0.3.3 后缀排序
巧妙的方法：用subString创建一个由字符串s的所有后缀字符串（由字符串的所有位置得到的子字符串）
组成的数组，然后将数组排序。

原字符串的每个子字符串都是数组中的某个字符串的前缀，排序以后，最长的重复子字符串
会出现在相邻的位置。因此遍历排序后的数组即可在相邻元素中找到最长公共前缀。

### 6.0.3.4 定位字符串
在大量文本中寻找某个特定的子字符串，可见5.3节。
当文本比查找的文本大得多时，可预先处理查找的pattern，以保证高效地查找，即5.2节。

当在网络浏览器输入字符串时，搜索引擎必然预先计算得到一张索引表，因为它不可能
即时根据输入，扫描所有互联网，理想情况，有一张反向索引表将被查找的字符串和网页关联起来。

很明显，这样的表会巨大，因此压缩它的体积，可见3.5.5节的PAGERANK 算法 ，按照重要程度排序。
另一种是将多个关键词 作为 预处理的 索引表的 键并合 URL 关联，那么当你查找一个关键词时，
先找到相对应的网页，在根据子字符串查找来定位关键词。这种排序的问题就是，文本是everything，但
你找的是thing，找不到。

对于某些应用，构造一个能够找到任意子字符串但索引是值得但。因此后缀排序可以拿来使用。
问题就是子字符串太大。
### 6.0.3.5 API及其用例
### 6.0.3.6 实现
### 6.0.3.7 性能
注意目前版本但substring已经被重写，浪费了大量空间,否则还是蛮好的。
### 6.0.3.8 改进实现
目前的实现对于大量重复相同子字符串的情况性能很糟糕，此外查找最长的时间是子字符串
长度的平方级别。

构造一棵后缀子字符串树[利用了高位排序]（后缀数组）

# 4.网络流算法
### 6.0.4.1 物理模型
一组相互链接大小不一的输油管道，在连接处有开关控制流向。

问题：如何配置开关使得流量最大化？

使用一个加权有向图模拟构造问题模型。
### 6.0.4.2 定义
定义： 一个流量网络是一张 边的权重（容量）为正的加权有向图，一个st-流量图有两个已知顶点，起点s和终点t。

流向一个顶点的总流量称为流入量，流出一个顶点的总流量称为流出量，两者之差即是净流量。

定义： st流量网络中的st流量配置 是由一组和每条边相关联的值组成的集合，这个值被称为 边的流量。
如果所有边的流量均小于边的容量且满足每个顶点局部平衡（即净流量为0，st除外），那么这个方案就是可行的。

最大st流量。
### 6.0.4.3 API
### 6.0.4.4 Ford-Fulkerson 算法
增广路径算法。

考虑一个流量网络中的任意一条从起点到终点的有向路径。
假设x为该路径上的所有边中未使用容量的最小值，那么只需将所有边的流量增大x，即可
将网络中的总量至少增大x，反复这个过程，就得到了一种流量分配方法：
找到另一条路径，增大路径中的流量，如此反复直到所有从起点到终点的路径上至少有一条边是饱和的。
但有些情况，这种思路走不通。

把之前的有向图变成无向图来思考问题，在这样的路径中，当沿着路径从起点向终点
，经过某条边的方向和流量的方向相同，那么这条边为正向边；反之，则为逆向边。
对于任意非饱和正向边和非空逆向边，我们通过增加正向边的流量，降低逆向边的流量
来提高总流量。流量的增量 受 路径上所有正向边 的未使用容量的最小值 和 所有
逆向边的流量 的限制。这样的一条路径被称为增广路径。

Ford-Fulkerson 最大流量算法，网络中的初始流量为0，沿着任意从起点到终点的增广
路径增大流量，直到不存在这样的路径。
### 6.0.4.5 最大流-最小切分定理
定义 流量切分是将顶点s和顶点t分配于不同集合中的切分。

在一个st-切分中，每条横切边要么是一条含有s的集合指向含有t的集合的st-边，
要么是反向的ts-边。我们将st-的集合称为切分集。

在流量网络中，一个st-切分的容量为该切分的st-边的容量之和，st-切分的
跨切分流量（就是流入或者流出量）是切分的所有st-边的流量之和和所有ts-边
的流量之和的差。

最小st-切分，给定一个st网络，找到容量最小的切分。

最小切分并没有提到流量，似乎和增广路径算法无关，从表面看，
计算最小切分（得到一组边）似乎比计算最大流量更容易（边赋值）。
流量和切分的以下基本关系证明流量网络中的局部平衡意味着整个网络的全局平衡，
并且可以得到任意流量值的上限。

命题E 对于任意的流量网络，每种切分中的跨切分流量都和总流量的值相等

证明 设Cs为含有顶点s的集合，Ct为含有t的集合。对Ct使用归纳法，当Ct仅含有t时
该命题成立，若将一个顶点由Cs移动到Ct，则该节点处的局部平衡以为可以保持这种性质。
因此，通过移动顶点可以得到任意st切分。

推论 s的流出量等于t的流入量

推论 st流量网站的值不可能超过任意st切分的容量

命题F 最大流量-最小切分定理 令f为一个流量网络，以下三种条件是等价的
+ 存在某个st切分，其容量和f流量相等
+ f达到了最大流量
+ f不存在任何增广路径

证明 根据E的推论，由1可得2，因为增广路径意味着更大的流量，与f的最大流量冲突，因此可由2得3。
但还需证明1，3等价。

### 6.0.4.6 剩余网络
通用的算法，并没有指定寻找增广路径的算法，如何才能找到不含有饱和
正向边和空逆向边的路径呢？

定义 给个某个流量网络和流量配置。剩余网络中的顶点和原网络相同，原网络中的
每条边都对应剩余网络中的 1-2条边。它的定义如下，对于原网络中的每条从v到w
的边e，fe为其流量，ce表示其容量。如果fe为正数，则将w->v加入剩余网络且容量为fe，
如果fe小于ce，将边v->w加入剩余网络，且容量为ce-fe

见图，剩余网络理流量对应的边的方向与流量本身的方向相反。正向边表示的是剩余容量（即如果从此通行能增长的流量）；
逆向边表示了实际流量（即从此通行减少的流量）

剩余网络使得我们可以通过图的搜索方法来寻找增广路径，因为剩余网络中所有从起点到终点
的路径都是原网络中的一条增广路径。
### 6.0.4.7 最短增广路径算法
用广度优先搜索
### 6.0.4.8 性能
# 5.问题归约
定义： 如果能够用来解决问题B的算法得到一个解决问题A的算法，则说明问题A能被归约为问题B 。

### 1.排序问题
高效的排序能解决很多看起来和排序无关的问题
+ 寻找中位数
+ 不重复的值
+ 最小平均完成时间的调度问题（拓扑排序）

还需要关注归约的成本。

问题解决模型，和成熟的库一样，设计良好的问题解决模型能扩展我们处理的问题域。但是过度关注模型
也会产生锤子问题：如果你有一把锤子，那么什么东西看起来都像钉子。
### 2 最短路径
### 3.最大流量问题
处理网络或者图问题
### 4.线性规划
运筹学的基础之一就是线性规划：
给定一个由M个线性不等式组成的集合和含有N个决策变量的线性等式，以及一个由该N个
决策变量组成的线性目标函数，找出能使目标函数的值最大化的一组变量值，或者证明不存在这样的结果。

# 6.不可解性
### 1.准备工作
图灵机
+ 普遍性。图灵机可以模拟所有物理可实现的计算设备。
+ 可计算性。图灵机无法解决的问题是存在的。
+ 扩展的丘奇-图灵论题。在任意计算设备上解决某个问题的某个程序所需的运行时间的增长数量级都是在图灵机上解决该问题的某个程序的多项式倍数。
### 2.指数级别的运行时间
不可解性在于区分能解决和最坏情况下需要指数级别才能解决的问题。
### 3.搜索问题
用一种模型来研究能解决的问题和不能解决的问题的关系。

定义 如果一个问题有解且验证它的解的正确性所需时间不超过输入规模的多项式，则称这种问题为搜索问题。
当一个算法给出了一个解，或是证明不存在解时，就称它解决了一个搜索问题。

我们用NP 描述所有搜索问题的集合。
### 4.其他类型的问题
其他方法抱愧决定性问题？最优性问题？搜索问题，决定性问题，最优化问题一般能够相互归约。
### 5.简单的搜索问题
定义 P 是能够在多项式时间内解决的所有搜索问题的集合。
### 6.非确定性
NP 中的N 即是 nondeterminism 。意思是扩展计算机能力的一种方法是赋予它不确定性：即断言当一个算法面对若干个选项，它有能力"猜出"正确的选择。
### 7.主要问题
没有人能找到任何一个问题并证明它 属于NP 而不属于P，
    P = NP 成立么？
### 8.多项式时间问题的归约
如果问题A 已知是难以解决的，且A在多项式时间里能归约为问题B ，那么B必然也是
难以解决的，否则问题B的一个多项式时间必然能够归约问A的一个多项式时间内的解。

推论：如果可满足性问题是难以解决的，那么线性规划也是难以解决的

难以解决的意思是不包含在P里。
### 9. NP完全性
许多问题属于 NP不属于P

定义 若NP中所有问题能在时间内归约为搜索问题A ，则称A为NP完全的

### 10.Cook-Levin 定理
或者 P=NP,即不存在任何不可解的搜索问题（所有搜索问题都可在多项式时间内解决）；
或者 P!= NP ,即存在不可解的搜索问题
### 11.问题分类
要证明一个问题存在于集合P ，需要证明解决它的算法时间为多项式，归约为一个已知的P类问题。
同理证明一个NP问题是NP完全，也一样。

将新问题归入容易解决的P或者难以解决的NP完全 可能会出现以下情况
+ 显而易见的，高斯消元法证明线性等式可满足性问题属于集合P
+ 需要一些技巧但并不困难。
+ 非常有调整性
+ 有待解决

这些问题需要分类。。。
一些著名的NP完全问题
+ 布尔可满足性
+ 线性规划
+ 负载均衡
+ 顶点覆盖
+ 汉密尔顿路径
+ 蛋白质折叠
+ 伊辛模型
+ 给定收益的风险投资组合
### 12.处理NP 完全性







 
 





 