# 应用
几个代表性例子
+ 能够快速并灵活地从文件中提前由逗号分割的信息的一个字典程序和一个索引程序。逗号分割的格式常见于存储网络信息
+ 为一组文件构建逆向索引的一个程序
+ 一个表示稀疏矩阵的数据类型。

第六章，符号表表示图，和处理字符串。

用ST表示RedBlackBST 用HashST 表示LinerProbingHashST
## 3.5.1 应使用哪一种实现
一般选择散列表或者二叉查找树

相对二叉查找树，散列表代码简单，且查找时间最优。
相对散列表，二叉树抽象数据结构简单，红黑树的在最坏情况下支持更多操作

                    符号表的各种实现的性能总结
    算法（数据结构）                最坏情况               平均情况         关键接口            内存
                            查找     |    插入      查找命中  |     插入                      
    顺序查找（无序链表）         N            N         N/2           N     equals            48N
    二分查找（有序数组）         lgN          N         lgN          N/2    compareTo         16N
    二叉树查找                 N            N        1.39lgN       1.39lgN compareTo        64N
    红黑树                    2lgN        2lgN      1.00lgN        1.00lgN compareTo       64N
    拉链法（链表数组）         <lgN         <lgN       N/(2M)       N / M    hashcode,equals 48N+64M
    线性探测（并行数组）        clgN        clgN       <1.5         <2.5     hashcode,equals  32N-128N
### 3.5.1.1 原始数据类型
不要用包装类，用原始数据类型。

键是整形Integer，值是Double，推荐用原始数据替代
### 3.5.1.2 重复键
有些应用需要同一个键绑定多个值
### 3.5.1.3 Java标准库
TreeMap 红黑树 HashMap拉链法
## 3.5.2 集合的API
某些用例不需要处理值，只需插入，并判定是否存在     
            
           集合数据类型的一组基本API
        public          class       SET<Key>
                        void        add(Key key)
                        void        delete(Key key)
                        boolean     contains(Key key)
                        boolean     isEmpty()
                        int         size()
                        String      toString()
                        
如果需要并 交 补 和其他数学集合的操作扩展set则更复杂，
基于符号表ST，SET类分有序和无序两个版本
### 3.5.2.1 dedup
（比如网络读取一段小型数据）
过滤器的例子filter一般被称为dedup（去重）
### 3.5.2.2 白名单和黑名单
## 3.5.3 字典类
这类用例的常见例子：
+ 电话黄页
+ 字典
+ 账户信息
+ 基因组学
+ 实验数据
+ 编译器（变量和内存地址）
+ 文件系统
+ 互联网DNS
## 3.5.4 索引类用例
一个键和多个值关联，我们用索引来描述这种多个关联的符号表，例子
+ 商业交易
+ 网络搜搜
+ 电影和演员
将每个键关联的值都放入一个数据结构，比如queue

### 反向索引
根据值查找键
+ 互联网电影数据库
+ 图书索引。对照索引，根据值反应所有的键
+ 编译器
+ 文件搜索
+ 基因组学

文件索引,改进思路：
+ 查询形式
+ 被索引的文件或网页的集合
+ 文件或网页在结果中的排序
## 3.5.5 稀疏向量
（google基于此）矩阵和向量的乘法，并计算结果向量，我们只考虑N行N列的方针，向量大小为N，java里实现
所需时间为N^2,因为N十分巨大，因此需要更好的算法

因为这里的矩阵往往是稀疏的，即大多数项为0，见spareVector
，当N巨大时，就很有意义。

















         
    