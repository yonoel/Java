# 散列表
使用散列的查找算法分为两步
+ 使用散列函数将查找的键转为数组的一个索引
+ 处理碰撞冲突的过程。两种解决方法，拉链法和线性检测法

散列表是算法在时间和空间上做出权衡的经典例子，如果没有内存限制，我们可以直接
将键作为数组索引，一方面键可能很大，另一方面有时间限制

## 3.4.1 散列函数
我们需要一个函数，易于计算并且能均分分布所有的键。

散列函数和键的类型有关，严格说，对于每种类型的键我们都需要一个与之对应的散列函数。
### 3.4.1.1 例子
比如社会保险号
### 3.4.1.2 正整数
将整数散列的最常用方法是除留余数法。我们选择大小为素数 M 的数组，对于任意的数
k，计算k除以M的余数，那么结果会分布在0-（M-1）中
### 3.4.1.3 浮点数
如果键是0-1之间的浮点数，我们将它 * M 并四舍五入 则得到一个 0 - （M-1）的键值。
缺陷是，键的高位起的作用更大，最低位对散列的结果没有影响，修正方法是将键表示为二进制然后使用除留余数法（Java）
### 3.4.1.4 字符串
```
int hash = 0
for(int i = 0; i < s.length(); i++)
    hash = (R * hash + s.charAt(i)) % M
```
charAt返回一个非负16位整数，如果R比任何字符的值都大，这种计算相当于将字符串当作一个
N位的R进制值，在对M取余
### 3.4.1.5 组合键
```
int hash = (((day * R + month) % M) * R + year ) % M
```
### 3.4.1.6 Java的约定
每种数据类型都需要相应的散列函数，于是java所有数据类型都继承留一个32位的hashCode方法，
每一种数据类型的hashCode方法都必须和equals方法一致。

默认散列函数返回对象的内存地址值
### 3.4.1.7 将hashCode的返回值转化位一个数组索引
因为我们需要的是一个数组索引而不是这个32位的整数值，在实现里将默认的方法取余山生一个0-（M-1）的值
```
 (x.hashCode() & 0*7fffffff ) % M
```
### 3.4.1.8 自定义hashCode
简单做法：将对象中的每个变量的hash转化为32位整数并计算得到散列值，对于原始数据类型，将其转化为对应的数据类型再调用hashcode
### 3.4.1.9 软缓存
如果计算很耗时，我们可以将每个键的散列值缓存起来，在每个键里用个hash变量来保存，java中的String就是这么干的。
总的来说，要为一个数据类型实现一个优秀的散列方法需要满足三个条件：
+ 一致性，等价的键必然产生等价的散列值
+ 高效性
+ 均匀性
但是，在有性能要求时，我们应谨慎使用散列。
保证均匀性的最好办法就是保证键的每一位都在散列值的计算中起到了相同的作用。

计算散列函数和比较两个键，哪个耗时更多，你的散列函数能均匀分布么？

假设J，我们使用散列函数能够均匀并且独立地将所有键分布于0 到 M-1 之间

## 3.4.2 基于拉链法的散列表
碰撞处理，也就是处理两个或多个键的散列值相同的情况

一种直接的办法将大小为M的数组中的每个元素指向一条链表，链表中每个节点存储了
散列值为该元素索引的键值对，这种被称为拉链法。

查找分两步，首先根据散列值找到对应的链表，然后沿着链表顺序查找相应的键。

我们最后用了M条链表保存了N个键，链表的平均长度是M / N （将之前的链表结构和散列构成一个新的数据结构（数组下封装链表））
，因为默认997条链表，因此对于较大的符号表，这种实现比链表结构更快；更可靠的方案是动态调整
链表数组的大小，链表越短，查找越快

命题K，在一张含有M 条链表和 N个键的散列表种 ，任意一条链表中键的数量均在 N / M 的常数因子范围内的概率无限趋向于 1 

证明，假设j是成立的。由二项分布可知，一条给定的链表正好有K个键的概率为 见PDF312

性质L，在一张含有M条链表和N个键的散列表中，未命中查找和插入所需的比较次数～N / M

### 3.4.2.1 散列表的大小
在实现基于拉链法的散列表时，我们的目标是选择适当的数组大小M
### 3.4.2.2 删除
### 3.4.2.2 有序性
散列的目的在于均匀地将键散开，因此键的顺序信息就没了

## 3.4.3 基于线性探测法的散列表
实现散列表的另一种方式就是用大小为M的数组保存N个键值对 ，其中 M > N,我们使用数组中的空位解决冲突，基于这种策略的所有方法被统称为开放地址散列表

最简单的方法叫做线性探测法。当碰撞（hash值相同）发生时，直接检查下一个位置，产生三种结果
+ 命中，该位置的键和被查找的键相同
+ 未命中，键为空（该位置没键）
+ 继续查找，该位置的键和被查找的键不同
用散列函数找到键在数组中的索引，检查键是否相同，不同继续查找，直到找到或者一个空元素

这种开放地址类的散列表的核心思想是 与其将内存用作链表，不如将它们作为散列表的空元素。
### 3.4.3.1 删除
这里就有问题了，无法随便删除，因为散列值会重复，不难保证设空后，再次根据这个键访问时，还能访问到此键。
因此，我们需要将簇中被删除键的右侧的所有键重新插入散列表（遇空就结束了）。

开放地址类的散列表性能也依赖于 N / M ，但意义不同，此时这个比率是散列表的使用率（永远小于1），对于拉链法，则是每条链表的长度（大于1）
### 3.4.3.2 键簇
线性探测的平均成本取决于元素在插入数组后聚集成的一组连续的条目，也叫做键簇。

显然，短小的键簇才能保证高效。明显插入越多，越不可能。
### 3.4.3.3 线性探测法的性能分析
。。。里程碑式的算法分析
## 3.4.4 调整数组大小
### 3.4.4.1 拉链法
这个调整大小的方法同样适用于拉链法，使得拉链法保持较短的链表（平均长度在2-8）；
当然拉链法并不是必须调整数组大小，但是线性探测法必须
### 3.4.4.2 均摊分析
当我们需要动态调整大小时，就要考虑成本了。

命题N。假设一张散列表能够自己调整数组大小，初始为空。基于假设，执行任意顺序的t次
查找，插入，删除，所需的时间都和t成正比。

## 3.4.5 内存使用
                    符号表的内存使用
        方法          所需内存
        拉链法         48N+32M
        线性探测        32N ～ 128N
        各种二叉查找树     56N
        
拉链法和线性探测法的详细比较取决于实现的细节和用例对空间和时间的要求。

散列表也有缺陷
+ 每种类型的键都需要一个优秀的散列函数
+ 性能保证来自于散列函数
+ 散列函数的计算可能复杂且昂贵
+ 难以支持有序性操作
 
        

