# 散列表
使用散列的查找算法分为两步
+ 使用散列函数将查找的键转为数组的一个索引
+ 处理碰撞冲突的过程。两种解决方法，拉链法和线性检测法

散列表是算法在时间和空间上做出权衡的经典例子，如果没有内存限制，我们可以直接
将键作为数组索引，一方面键可能很大，另一方面有时间限制

## 3.4.1 散列函数
我们需要一个函数，易于计算并且能均分分布所有的键。

散列函数和键的类型有关，严格说，对于每种类型的键我们都需要一个与之对应的散列函数。
### 3.4.1.1 例子
比如社会保险号
### 3.4.1.2 正整数
将整数散列的最常用方法是除留余数法。我们选择大小为素数 M 的数组，对于任意的数
k，计算k除以M的余数，那么结果会分布在0-（M-1）中
### 3.4.1.3 浮点数
如果键是0-1之间的浮点数，我们将它 * M 并四舍五入 则得到一个 0 - （M-1）的键值。
缺陷是，键的高位起的作用更大，最低位对散列的结果没有影响，修正方法是将键表示为二进制然后使用除留余数法（Java）
### 3.4.1.4 字符串
```
int hash = 0
for(int i = 0; i < s.length(); i++)
    hash = (R * hash + s.charAt(i)) % M
```
charAt返回一个非负16位整数，如果R比任何字符的值都大，这种计算相当于将字符串当作一个
N位的R进制值，在对M取余
### 3.4.1.5 组合键
```
int hash = (((day * R + month) % M) * R + year ) % M
```
### 3.4.1.6 Java的约定
每种数据类型都需要相应的散列函数，于是java所有数据类型都继承留一个32位的hashCode方法，
每一种数据类型的hashCode方法都必须和equals方法一致。

默认散列函数返回对象的内存地址值
### 3.4.1.7 将hashCode的返回值转化位一个数组索引
因为我们需要的是一个数组索引而不是这个32位的整数值，在实现里将默认的方法取余山生一个0-（M-1）的值
```
 (x.hashCode() & 0*7fffffff ) % M
```
### 3.4.1.8 自定义hashCode
简单做法：将对象中的每个变量的hash转化为32位整数并计算得到散列值，对于原始数据类型，将其转化为对应的数据类型再调用hashcode
### 3.4.1.9 软缓存
如果计算很耗时，我们可以将每个键的散列值缓存起来，在每个键里用个hash变量来保存，java中的String就是这么干的。
总的来说，要为一个数据类型实现一个优秀的散列方法需要满足三个条件：
+ 一致性，等价的键必然产生等价的散列值
+ 高效性
+ 均匀性
但是，在有性能要求时，我们应谨慎使用散列。
保证均匀性的最好办法就是保证键的每一位都在散列值的计算中起到了相同的作用。

计算散列函数和比较两个键，哪个耗时更多，你的散列函数能均匀分布么？

假设J，我们使用散列函数能够均匀并且独立地将所有键分布于0 到 M-1 之间

## 3.4.2 基于拉链法的散列表
