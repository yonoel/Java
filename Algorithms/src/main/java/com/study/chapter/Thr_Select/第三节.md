# 3.3 平衡查找树
在动态插入中保证树的完美平衡代价太高，稍微放松要求
## 3.3.1 2-3查找树
为了保证平衡，我们需要一些灵活性，比如，我们允许树中的一个节点保存多个键。
确切地说，我们将一棵标准的二叉树中的节点称为2-节点（含有一个键和两条链接），
现在我们引入3-节点，它有两个键三条链接。2-和3-节点中的每条链接都对应着其中保存的键所分割产生的一个区间。

定义。一棵2-3 查找树或为一棵空树，或有以下节点组成：
+ 2- 节点，含有一个键（及其值），和两条链接，左链接指向的 2 - 3 树中的键都小于该节点，右链接都大于
+ 3- 节点，含有两个键（及其值），和三条链接，左都小于，中链接的树的键都在该节点的两个键之间，右链接都大于
指向空树的链接称为空链接 
### 3.3.1.1 查找
类似二叉查找树
### 3.3.1.2 向 2- 节点中插入新键
如果还像二叉树那样，先查找，如果不存在，然后挂在树的底部，无法做到平衡型。
因此我们需要区分开节点。

如果查找未命中的是一个2 - 节点，我们把这个2- 节点替换为 3- 节点
### 3.3.1.3 向一棵只有一个 3- 节点的树中插入新键
先考虑只有一个这样的节点。

首先，将新键存入，使之成为一个 4- 节点，含有三个键四个链接。
在把这个节点转为 3 个 2- 节点（中键的节点作为根节点） ，这是一棵完美平衡的二叉树
### 3.3.1.4 向一个父节点为 2- 节点的 3- 节点中插入新键
假设最后的未命中节点的父节点是一个 2- 节点，而查找结束于一个 3- 节点。

首先，还是构造一个 4- 节点，但这次的中键的节点不是新节点，而是移动至原来的父节点使其成为一个 3- 节点
其次两个节点都成为了2个 2- 节点。
### 3.3.1.5 向一个父节点为 3- 节点的 3- 节点中插入新键
如上，构造一个 4- 节点，因为父节点也是 3- ，因此也变成了一个 4- 节点，递归上去，继续到其父节点，一直到遇到一个 2- 节点，或是回到根节点
### 3.3.1.6 分解根节点
如果插入节点时，所有路径上都是 3- 节点，因此根节点也变成了一个 临时的 4- 节点，分解根节点，树高+1
### 3.3.1.7 局部变换
将一个 4- 节点分解为一棵 2- 3 树的可能性有6种情况，这个4- 节点可能是根节点，
可能是 2- 节点的左或右，也可能是 3- 节点的左中右节点。

2-3 树的插入算法根本在于这些变换都是局部的，变更的数量都是很小的常数。
### 3.3.1.8 全局性质
因此这些局部变换，不影响到树的全局有序性和平衡型

标准的二叉树是由上向下生长，（没有放底部）； 2-3 树是由下向上生长。

命题F,在一棵大小为N的 2-3 树中，查找和插入操作访问的节点必然不超过LgN个。

证明。

但是，需要处理的情况很多，需要维护两种不同类型的节点，需要大量的代码，所产生的额外
开销可能使数据结构比二叉树更慢，平衡一棵树的初衷是为了消除最坏情况，但我们希望解决问题
的代码越少越好

## 3.3.2 红黑二叉树
### 3.3.2.1 替换 3- 节点
红黑二叉树的背后的基本思想是用标准的二叉树和一些额外的信息（替换 3- 节点）来表示 2-3 树。

我们将链接分为两种类型
+ 红链接，将两个 2- 节点链接起来构成一个 3- 节点，确切说， 3- 节点表示为由一条左斜的红色链接 相连的 两个 2-  节点；（a-b这样的3-节点，变成 a-b这样的2个 2- 节点）
+ 黑链接， 2-3 树中普通的链接，那就可以推出来。。黑链接必定右侧节点为空，而且在树右侧

这样的表示法，我们无需修改就可以直接使用标准二叉树里get方法，对于任意的 2-3 树，只要对
节点进行转换，我们都可以派生出一棵对应的二叉查找树。这种树被成为 红黑二叉树
### 3.3.2.2 一种等价的定义
红黑树的另一种定义是含有红黑链接并满足下列条件的二叉查找树
+ 红链接均为左链接
+ 没有任何一个节点同时和两条红链接相连
+ 该树是完美黑色平衡，即任意空链接到根节点的路径上的黑链接数量相同
### 3.3.2.3 一一对应
（图像表示）如果我们将一棵红黑树的红链接画平，而不是二叉树的上下结构，那明显这就是一棵 2-3 树
### 3.3.2.4 颜色表示
方便起见，每个节点都只会有一条指向自己的链接（从父节点指向它），我们将该链接
的颜色保存在节点私有变量布尔值color中，如果为红色，值为true，否则false。

为了代码清晰，编写测试方法isRed
### 3.3.2.5 旋转
实现中可能会出现红色右链接，或者两条连续的红链接，因此要修复它。。简称旋转

首先，假设有一条红色的右链接需要被转换成左链接，这个被称为左旋转。比如右侧的一个节点是红链接，然后要修复它。看图

这个方法接收一条指向红黑树中的某个节点的链接作为参数。
### 3.3.2.6 在旋转后重置链接
旋转返回一个链接（节点），递归的调用 h = rotateleft(h)，指向重新改变了

在插入时使用旋转保证 红黑树的一一对应关系，也保证了有序性和完美平衡性（还有两个性质：不存在两条连续的红链接，和不存在红色的右链接）
### 3.3.2.7 向 2- 节点中插入新键
比如，只含有一个键的红黑树，插入一个键，
若小于该键，新增红节点。
若大于该键，新增的节点为理论上是黑链接，然而这是一个红色的右链接（因为也是 2- 节点），此时就要旋转该节点，左旋转
### 3.3.2.8 向树底部的 2- 节点中插入新键
左旋
### 3.3.2.9 向一棵双键树 （3- 节点）中插入新键
有三种情况，既然是 3- 节点 ，就是已经有两个键，插入的这个键在此两键的哪个范围内
+ 新键大于两键，明显右链接，根节点为中间的键，并且这个根节点应当变成黑链接
+ 小于两键，左链接，左链接，产生连续的两个红链接，右旋转，获取黑链接
+ 在两键中间，那明显新键应当是根节点，红链接最小键的右侧，然后左旋转
### 3.3.2.10 颜色转换
专门写个方法filpColor来转换两个红色子节点的颜色，还需要将父节点的颜色也改变

### 3.3.2.11 根节点总是黑色
红色的根节点说明这是一个3- 节点，但实际情况，我们每次插入都会使根节点变成黑色
（旋转）
### 3.3.2.12 向树底部的 3- 插入新键
### 3.3.2.13 将红链接在树中向上传递
2-3 树中的插入需要我们分解 3- 节点，在中间键插入父节点，知道遇到一个 2- 节点
或是根节点
+ 如果右子节点是红色，而左子节点是黑色，左旋
+ 如果左子节点是红色，同时它的左子节点也是红色，右旋
+ 如果左右均是红色，颜色转换
## 3.3.3 实现
PUT
## 3.3.4 删除
比put更复杂，因为不仅要在 构造临时 4- 节点时沿着查找路径向下变换，
还要在分解 4- 节点时沿着查找路径向上变换（同插入）
### 3.3.4.1 自顶向下的 2-3-4 树
先学一个简单的算法 2-3-4 树的插入算法，这样的树允许存在 4-节点，
它的插入算法沿着路径向下，并保证当前节点不是 4- 节点（这样树底才有空间）；
沿着路径向上，将之前的 4- 节点配平。
红黑树实现的步骤：
+ 将 4- 节点表示为由三个 2- 节点组成的平衡的子树，根节点和子节点通过红链接相连
+ 在向下的过程中将 4- 节点分解并颜色转换
+ 在向上时，用旋转，将4- 节点配平
总结，只需将flipcolors的语句，移动到递归调用之前即可。。
### 3.3.4.2 删除最小键
从树底，删除3-节点简单， 但 2- 节点比较复杂，因为 2- 节点删除会产生一个空节点。如果用空链接
替代它，显然这棵树的平衡性就没了。

因此，我们沿着左链接向下变换，确保当前不是 2- 节点（删 3- ，或者 4- 依旧完美平衡）

首先，根节点有两种情况，如果根是 2- ，且子节点都是 2- ，我们直接把这三个节点变成 4-

沿着左链接向下的过程中，需保证以下情况
+ 如果当前节点不是 2- ，完成
+ 如果当前节点是2- 而它的兄弟节点不是 2- ，兄弟节点的一个键（作为根），根替代当前节点
+ 如果兄弟和当前都是2- ，那么和父节点，共同构成 4- 节点
最后这个最小键的节点必然是个 2- 或者 3- 节点
### 3.3.4.3 删除操作
在查找同时和删除操作的同时进行同样的转换操作，可以保证查找过程中当前任意节点都不是 2- 
，如果查找的结果在底部，直接删除，如果不是，则需要将它和它的后继节点交换。
问题已经转变成在一棵根节点不是 2- 的子树中删除最小的键，然后删完后，需要回溯，分解 4- 节点
（这是同时实现了，高效的查找，插入和删除的符号表实现）
## 3.3.5 红黑树的性质
所有基于红黑树的符号表的实现均能保证操作的运行时间是对数级别（范围查找除外（需要返回键））
### 3.3.5.1 性能分析
首先，无论键怎么插，红黑树几乎是完美平衡的

命题G，一棵大小为N的红黑树的高度不会超过2LgN
证明，最坏情况，最左侧都为3- ，其余都为2-。

命题H，一棵大小为N的红黑树，根节点到任意节点的平均路径长度～1.00lgN

红黑树的get不检查颜色，因为树是完美平衡，因此查找比二叉树更快。它的查找只进行一次比较并更新链接，和二分查找类似（只有比较和索引计算）。

### 3.3.5.2 有序符号表API
红黑树复杂的只有put和delete，其他api不做任何改动就可以使用。

                            各种符号表实现的性能总结
        算法（数据结构）                最坏情况                            平均情况                 是否支持有序性
                                查找     |      插入                查找      |     插入
         顺序查询（无序链表）        N              N                 N/2             N               否
         二分查找（有序数组）        LgN            N                 lgN             N/2             是
         二叉树                    N              N                1.39lgN         1.39lgN          是
         红黑树                    2lgN          2lgN              1.00lgN         1.00lgN          是
                 

















