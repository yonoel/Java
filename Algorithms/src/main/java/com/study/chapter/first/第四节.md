#1.4 算法分析
## 1.4.1 科学方法
再多的实验也不一定能够证明我是对的，但只需要一个实验就能证明我是错但
## 1.4.2 观察
第一个定量观察就是计算性任务但困难程度：问题的规模
### 1.4.2.1 举例
ThreeSum
### 1.4.2.2 计时器
### 1.4.2.3 实验数据的分析
程序在不同计算机上的运行时间之比是个常数

x轴表示N（问题规），y轴表示时间T（N）
a为常数

lg(T(N)) = 3 lgN+lg a

很明显，这个公式等价于T(N)=aN^3

对数图中的直线等价于对于T(N)=aN^b的猜想，这种公式被成为幂次法则

## 1.4.3 数学模型
一个程序运行的总时间主要和两点有关
1. 执行每条语句的耗时
2. 执行每条语句的频率
### 1.4.3.1 近似
 if语句的执行次数
 
 N*（N-1）(N-2)/6 = (N^3) /6 - (N^2)/2 + N/3
 
 显而易见，当N很大时，只有首项有意义
 定义：
    我们用~f(N)表示随着N增大除以f(N)的结果趋于1的函数；
    用g(N)~f(N)表示g(N)f(N)随着N增大趋近于1
    
常见的增长数量级函数

     描述             函数
     常数级别           1
     对数级别           logN
     线性级别           N
     线性对数级别        NlogN
     平方级别           N^2
     立方级别           N^3
     指数级别           2^N
### 1.4.3.2 近似运行时间
### 1.4.3.3 对增长数量级的猜想
性质A： ThreeSum 的运行时间增长数量级为N^3
### 1.4.3.4 算法的分析
### 1.4.3.5 成本模型
3-sum的成本模型是访问数组的次数

目前的暴力算法使用了~(N^3)/2次访问数组
### 1.4.3.6 总结
对于大多数程序，得到运行时间的数学模型需如下步骤
1. 确定输入模型，定义问题规模
2. 识别内循环
3. 根据内循环中的操作确定成本模型
4. 对于给定的输入，判断执行频率

如果一个程序含有多个方法，分别讨论

二分查找。输入是大小为N的数组，内循环是while语句内的所有语句
成本模型是比较操作（比较两个元素的大小），比较次数最多为lgN+1

白名单。输入是大小为N的白名单和标准输入的M个整数，且M>>N
内循环也是while语句，成本模型也是比较操作（承自二分查找），比较次数为M(lgN+1)

因此白名单的增长数量级别近似为MlgN：
 + 如果N很小，那么M，N（输入和输出）都是主要成本，
 + 比较次数的取决于输入M 在～M和~M(lgN)之间
 + 假设排序的成本<<MlgN
 
                    常见函数
        描述             记号           定义
        向下取整floor     [x]
        向上取整ceiling
        自然对数          lnN            loge(N) e^x = N
        以2为底的对数      lgN            log2(N) 2^x = N
        以2为底的整形对数
        调和级数           Hn            1 + 1/2 + 1/3 + .... 1/N
        阶乘              N!            1*2*3*4*。。。。*N
                    常用的近似函数
        调和级数求和      Hn = 1 + 1/2 + 1/3 + .... + 1/N ~lnN
        等差数列求和      ~ (N^2)/2
        等比数列求和      1+2+4+8+。。。。+N=2N-1 ~2N,其中N=2^n
        斯特灵公式       lgN! = lg1+lg2+....+lgN ~ NlgN
        二项式系数       
        指数函数         (1-1/x)^x ~1/e
## 1.4.4 增长数量级的分类
            对增长数量级的常见假设的总结
        描述          增长的数量级别         典型的代码           说明       举例
      常数级别              1              a = b + c        普通语句            
      对数级别           log N              二分查找         二分策略       二分查找
      线性级别             N              for ()             循环
      线性对数级别        N log N                             分治        归并排序
      平方级别           N ^ 2            for( for( ))      双层循环      检查所有元素对
      立方级别                                              三层循环
      指数级别              2^ N                            穷举查找       检查所有子集
### 1.4.4.1 常数级别
### 1.4.4.2 对数级别
### 1.4.4.3 线性级别
### 1.4.4.4 线性对数级别
### 1.4.4.5 平方级别
### 1.4.4.6 立方级别
### 1.4.4.7 指数级别
## 1.4.5 设计更快的算法
解决3-sum
### 1.4.5.1 热身2-sum
假设2个求和，那么只要存在第二个数为-n，即存在
+ 如果二分查找返回-1，不增加
+ 如果返回的j>i，即存在a[j]+a[i] = 0
+ 如果返回的j<i，不增加
那么算法的增长级别为NlogN
### 1.4.5.2 3-sum的快速算法
当且仅当 -(a[i]+a[j])在数组中时，存在结果，算法的级别就变成了N^2logN
### 1.4.5.3 下界
对于2-sum，没有，成本模型仅允许使用并计算这些数的线性或者平方级别的函数

对于3-sum，不知道
## 1.4.6 倍率实验
+ 开发一个输入生成器来产生实际情况中的输入DoublingTest
+ 计算本次和上次的时间比值DoublingRatio
+ 反复运行知道比值接近于极限 2^b
这个方法对于比值没有极限的算法无效，但得出以下结论
+ 运行时间但增长级别为N^b
+ 要预测一个程序，将上次的时间*2^b并将N加倍

命题C 倍率定力，如果T(N) ~aN^blg N 那么 T(2N) / T(N)  ~2^b

在有性能压力的情况下应考虑倍率实验，估计运行时间
### 1.4.6.1 评估它解决大型问题的可行性
### 1.4.6.2 评估大型计算机的所产生的价值
很明显指数级别的没有意义
## 1.4.7 注意事项
### 1.4.7.1 大常数
### 1.4.7.2 非决定性的内循环
### 1.4.7.3 指令时间
缓存技术
### 1.4.7.4 系统因素
### 1.4.7.5 不分伯仲
### 1.4.7.6 对输入的强烈依赖
假设运行时间和输入无关，比如3-sum询问的是是否存在，那就强烈依赖于输入
### 1.4.7.7 多个问题参量
## 1.4.8 处理对于输入的依赖




      
       
      
                

 
 

