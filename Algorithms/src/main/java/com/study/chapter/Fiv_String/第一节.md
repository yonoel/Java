# 字符串排序
考虑使用字符串作为键，将学习两类完全不同的字符串排序，比之前学习的排序效率更高。

+ 第一类，从右到左检查键中的字符，这种被称为低位优先(LSD)的字符串排序。使用数字代替字符的原因要追溯到
相同方法在各种数字类型中，如果将一个字符串看作一个256进制的数组，那么从右至左检查
就等价于先检查数字的最低位，这种方法适用于键的长度相等的情况。

+ 第二类，从左至右检查，先看最高，被称为高位优先（MSD）的字符串排序。类似快速排序，区别在于高位优先，在切分时
仅使用键的第一个字符，快排涉及了所有键值。

## 5.1.1 键索引计数法
统计学生，学生按组分类
### 5.1.1.1 频率统计
使用数组count计算每个键（组）出现的频率
### 5.1.1.2 将频率转为索引
使用count来计算每个键（组）在排序结果中的索引位置，比如第一组3人，第二组5人，
第三组的起始位置就是8。比如之前的结果是
{0,0,3,5,6,6}
对于每个键值r，把count转化为索引表,结果是
{0,0,3,8,14,20}
### 5.1.1.3 数据分类
将所有元素（学生）转移到辅助数组aux进行排序，每个元素在aux的位置
有它的键（组）对应的count决定，在移动之后将count中的对应值+1，以保证
count[r]是下个键为r的元素在aux的位置。这里很关键，键相同的元素排序后聚集到一起，
但相对顺序没有变化。
### 5.1.1.4 回写

命题A 键索引计数法排序N个键为0到R-1个元素需要访问数组11N+4R+1次

证明 初始化数组访问数组N+R+1，
第一轮循环，N个元素使计数器加1（访问数组2N）；
第二次循环进行R次加法（访问数组2R次）；
第三次循环使计数器的值增大N次并移动N次数据（访问3N次）；
第四轮循环移动数据N次（访问数组2N）
## 5.1.2 低位优先的字符串排序
比如记录多少不同车辆经过一段高速公路。这种定长的字符串比较用索引计数法来实现排序，就
会快很多。

命题B 低位优先的字符串排序能够稳定地将定长字符串排序

证明 由命题A可知，该命题是完全依赖于键索引计数法的实现 是稳定的。在将最后i个
字符作为键排序后，可知任意两个键在数组中的顺序是正确的。
要么因为它们倒数第i个字符不同，因此排序已经将它门排序好。
要么倒数第i个字符相同，但是因为索引排序，它们仍然有序。

比如分纸牌，先按大小排序成13组，在按四组来分类，此时必定有序

低位排序是适用于一般应用的线性时间排序算法，无论N多大，只遍历W次数据

命题B 续 对于基于R个字符的字母表的N个长为W的字符串为键的元素，低位优先排序
需要访问~7WN + 3WR 次数组，使用的额外空间和 N + R 成正比

对于典型的应用 R 远小于 N ,因此低位优先排序运行时间和输入规模成正比

## 5.1.3 高位优先的字符串排序 
实现一个通用的字符串排序（字符串长度不一），其中之一就是从左到右排序（MSD）高位优先。
和快排类似，会将数组切分成能独立排序的子数组，但是每位不同的首字母都是一组，而不像快排只有2-3组。

### 5.1.3.1 对字符串末尾的约定
有种便捷的做法，将 所有字符已经被检查过的字符串所在的子数组 放在 所有子数组之前（已经排好的，先放前面）（替换charAt方法）
### 5.1.3.2 指定的字母表
高位优先的排序成本和字母表中的字符数量有很大关系，为了改进性能，做以下改动
+ 在构造函数中用alpha对象保存字母表
+ 在构造函数中将R设为字母表的R
+ 在charAt方法中替换charAt

                高位优先的字符串排序中 count[] 数组的意义
                                                    count[r]的值
        第d个字符排序的完成阶段            r=0                 r=1                 r在2与R-1之间         r=R         r = R+1
        频率统计                    0（这个时候没用）      长度为d的字符串数量               第d个字符的索引值是r-2的字符串的数量
        将频率转为索引        长度为d的字符串的子数组的起始       第d个字符第索引值是r-1的字符串的子数组的起始                 未使用
        数据分类              第d个字符第索引为r第字符串的子数组的起始索引                                  未使用         未使用
                       1+ 长度为d的字符串的子数组的结束索引     1+ 第d个字符串第索引值是r-1的字符串的子数组的结束索引          未使用
                       
请研究高位排序算法，这个代码简洁得令人刮目相看。这种算法不适用于过大的字母表。
                                            
### 5.1.3.3 小型子数组
高位优先排序的思想很有效，在一般应用中，检查若干字符就能完成所有字符排序，因为它把排序的数组
切分成若干个小的数组，但这种切分也带来了，大量的微型数组。

小型子数组的排序对高位优先排序的性能至关重要，类似的递归排序算法，比如归并，快速，同样。
因此将小数组切换到插入排序对于高位优先是必须的，否则性能太浪费了，为了避免重复检查
已知相同的字符所带来的成本。
### 5.1.3.4 等值键
高位优先的第二个陷进是对于含有大量等值键的子数组排序较慢。
如果这样的子字符串出现过多，切换成快速排序的条件将不会出现，那么递归就会检查小型数组。
其次索引计数法无法有效判断字符串中的字符是否全部相同。
### 5.1.3.5 额外空间
aux可以在方法里调用，不必私有变量。
### 5.1.3.6 随机字符串模型
### 5.1.3.7 性能
对于基于比较的排序，我们需要关注键，对于高位优先，键的顺序不重要
+ 对于随机输入，高位优先只检查足以区别字符串所需的字符。相对于输入
数据中的字符总数，算法的运行时间是亚线性的
+ 对于非随机输入，依旧是亚线性的，但需要检查的可能比随机情况更多
+ 对于最坏情况，检查所有字符，运行时间是线性的（和低位优先排序一样），这种情况就是输入中所有字符串都相同

检查字符数量并不是高位优先的字符串排序算法性能的全部，还需要考虑统计字符的出现频率
和将频率转化为索引需要的时间。

命题C 要将基于大小为R的字母表的N个字符串排序，高位优先平均需要检查 NlogrN 个字符。

证明 希望子数组的大小相同。。。。

命题D 将基于大小为R的字母表的N个字符串排序，高位优先访问数组次数在 8N + 3R 到 7wN + 3wR 之间，w是字符串的平均长度。

因此当N较小，R是主因子。给较大的子数组排序时，每个键都会产生一个子数组，
需要访问NR次，当小于M 切换成快排
时，将会有 N/M 个大小为M的子数组，在用 NM /4 比较和 NR/M次交换 。这说明应该选择与R的平方根成正比的M

命题D 续  要将基于大小为R的字母表的N个字符串排序，最坏情况高位优先所需空间与R*最长字符串的长度之积成正比。

因此，在用高位优先，基于大型字母表的长字符串排序时，消耗了过多的空间或者时间。

## 5.1.4 三向字符串快排
改进高位排序的快排，根据首字母三向排序
### 5.1.4.3 随机化
因为这就是快排，所以最好先打乱。。随机化更好。对于字符串类型的键，
标准的快排以及其他排序实际上都是高位优先类的字符串排序方法，因为
String类的compareTo是从左到右访问字符串的。
### 5.1.4.4 性能
考虑字符串键很长的情况，且键前面的大部分首字母相同，这种情况，
快排的性能与字符串的长度* 2NlnN 成正比，而三向 则与
N  * 字符串长度 再加上 2NlnN次比较的和成正比。因此
三向比快排少2lnN个

三向的性能不直接取决于字母表

### 5.1.4.5 举例， 网站日志
公共前缀，直接pass
## 5.1.5 字符串排序算法的选择
                                各种字符串排序算法的性能特点
                                                    基于R个大小的字母表调用charAt
    算法              稳定性          原地排序         的增长数量级（平均长度为w，最大为W）               优势领域
                                                    时间              额外空间
    插入                是             是              N-N^2            1                    小数组或者接近有序
    快排                否             是             NlgN             lgN                 通用排序，特别适用空间不足
    归并                是             否             NlgN              N                     稳定的通用，就是空间
    三向快排             否             是             N-NlgN          lgN                    大量重复键
    低位优先             是             否             NW                N                   较短的定长字符串
    高位优先             是             否            N-Nw               N+WR                  随机字符串
    三向字符串快排        否             是            N-Nw              W+lgN                通用排序，适用于含有较长公共前缀的字符串
    
                             
                







