# 正则表达式
## 使用正则表达式描述pattern
它由三种基本操作和作为操作数的字符组成
### 5.4.1.1 链接操作
当我们写出AB的时候，就指定了一种语言{AB},由AB链接而成
### 5.4.1.2 或操作
A|B = {A,B}，链接操作的优先级高于或操作
### 5.4.1.3 闭包操作
可以将模式的部分重复任意次数，闭包是由将模式和自身链接任意多次（包括0）而得到的
所有字符串组成的语言，我们使用 * 表示需要被重复，闭包优先级高于链接
AB*表示一个A和N个B的表示
### 5.4.1.4 括号
使用括号来改变优先级 C(AC|B)D 指定的是{CACD,CBD}，（）优先大于链接，大于闭包

定义 一个正则表达式可以是
+ 空字符串
+ 单个字符
+ 包含在括号中的另一个正则表达式
+ 两个或多个链接起来的正则表达式
+ 由或运算符分隔的两个或多个正则表达式
+ 由闭包运算符标记的一个正则表达式

定义（续） 每个正则表达式表示的都是一个字符串集合
+ 空正则的集合为空，0个元素
+ 一个字符有一个元素
+ 一个由括号和包含在其中正则所组成的正则的字符串集合与括号内的正则相同
+ 由两个正则链接起来的为这两个正则分别表示的字符串集合的叉乘
+ 由或运算符链接的两个正则为这两个正则分别表示的字符串集合的并乘
+ 由闭包表示的由重复任意次数得到所有字符串组成

## 5.4.2 写法
### 5.4.2.1 字符集描述符
                字符集描述符
        通配符       .
        指定集合     []
        范围集合     []，-分隔 [0-9]
        补集         []，首字母为^ [^0]
### 5.4.2.2 闭包的简写
                    闭包的简写
        至少重复1次          +
        重复0或1次           ？
        重复指定次数          {}
        重复指定范围的次数    {1-2}
        
### 5.4.2.3 转义序列
\
## 5.4.3 实际运用
### 5.4.3.1 子字符串的查找
### 5.4.3.2 合法性检查
### 5.4.3.3 程序员的工具箱
### 5.4.3.4 基因组
### 5.4.3.5 搜索
### 5.4.3.6 可能性
### 5.4.3.7 局限性
不存在 描述所有 合法正则的集合 的正则表达式
## 5.4.4 非确定有限状态机（NFA）
KMP是有限状态机，一共就R种状态。处理正则，就需要更抽象的自动机，因为存在或操作，状态无法根据一个字符判断出模式是否出现，其次由于有闭包(closure),
自动机甚至无法知道检查多少个字符算匹配失败。非确定性的自动机：当面对多种可能时，自动机能猜出正确的模式。

kleene定理，证明了对于任意正则表达式都存在一个与之对应的非确定有限状态机（反之亦然）。示例，说明了NFA的性质和操作，用来判断一段文本是否包含
正则((A*B|AC)D),如例子，我们定义的NFA有着以下特点
+ 长度为M的正则里每个字符所对应的NFA中都有且只有一个对应的状态值。NFA的初始状态为0，并含有一个接受状态M。
+ 字母表中的字符所对应的状态都有一条从它指出的边，这条边指向模式的下一个字符所对应的状态。（图结构？？？）
+ 元字符"(",")","|","*"所对应的状态至少含有一条指出的边（红色边），这些边可能指向其他的任意状态。
+ 有些状态有多条指出的边，但一个状态只能有一条指出的黑色边
```
由于NFA和DFA的能力是一样的，每个NFA必然可以转化成一个等价的DFA。既然DFA对每个输入可以到达的状态时是确定的，那么输入串s在NFA中可能达到的状态集合对应为等价DFA中某个状态。从这个思路出发，可以构造出DFA。

很容易理解，构造DFA的代价远大于NFA，假设NFA的状态数为K，那么等价DFA的状态数目理论上可达2的k次方，不过实际上几乎不会出现这么极端的情况，可以肯定的是构造DFA会消耗更多的时间和内存。

但是DFA一旦构造好了之后，执行效率就非常理想了，如果一个串的长度是n，那么匹配算法的执行复杂度是O(n);而NFA在匹配过程中，存在大量的分支和回朔，假设NFA的状态数为s，因为每输入一个字符可能达到的状态数做多为s，那么匹配算法的复杂度及时输入串的长度乘以状态数O(ns)。


```
图见NFA例子，约定所有的模式的都包含在括号里，因此NFA的第一状态是左括号，最后一个状态是右括号。和DFA意义，NFA也是从状态0开始读取文本的第一个字符，
NFA在状态转换中有时从文本中读取字符，从左向右一次一个，但它和DFA有着不同点：
+ 在图中，字符对应的是节点而不是边
+ NFA只有读取了文本中所有字符才能识别它，而DFA并不一定要读取全部内容。

NFA中从一个状态转移到另一个状态的规则也和DFA不同，在NFA中状态转换有以下两种方式
+ 如果当前状态和字母表中的一个字符相对应 且 文本中的当前字符和该字符匹配，自动机可以扫过文本中的该字符（由黑色的边）指向下一个状态，成为匹配转换
+ 自动机可以通过红色的边转换到另一个状态而不扫描文本中的任何字符，这种称为空字符串转换
见图NFA匹配过程，输入字段为AAAABD。

然后是如果是DFA就会失败的图例，说明失败的原因，因为NFA离开一个状态的转换有多种可能，转换是不确定--即空字符串转换。要使得NFA运行得有意义，必须使
NFA能够猜测对于给定的文本进行转换。换句话说，当且仅当一个NFA从状态0开始从头读取了一段文本中的所有字符，进行了一系列状态转换并最终到达了接受状态时，
则称之NFA识别了一个文本字符串。相反，当且仅当一个NFA没有任何匹配转换和空字符串转换 并达到接受状态时，称无法识别。

## 5.4.5 模拟NFA的运行
### 5.4.5.1 自动机的表示
表示NFA，正则已经给出了状态名（0到M之间所有到整数，M为pat长度），用char数组re[]保存pat，数组耶表示了匹配的转换（如果re[i]存在于字母表中，那么就存在
一个i到i+1到匹配转换）。空字符串转换的表示是有向图，我们用有向图G表示空字符串转换。比如之前的pat，就有以下条边:
+ 0-1
+ 1-2
+ 1-6
+ 2-3
+ 3-2
+ 3-4
+ 5-8
+ 8-9
+ 10-11
### 5.4.5.2 NFA的模拟和可达性
其实就是4.4里多点可达性问题？（4.2吧，有向图的单点或多点可达性问题）
。。。吧啦吧啦

命题Q:判定一个长度为M的模式的NFA识别长度为N的文本最坏情况和MN成正比

证明：对于长度为N的文本的每个字符，我们都会遍历一个大小不超过M的状态集合并在 空字符串转换的有向图中 进行深度优先。

识别流程：
没看懂，我的理解是先构造NFA这个有向图(这个图的边全是空字符串转换)，然后对于文本里的每个字符都创造了一系列的图集合，如果状态转换成功，则表示有匹配，
遍历了所有文本的字符，如果不匹配，根本不用管。。


## 5.4.6 构造NFA
构造NFA类似于1.3节里用Dijkstra双栈算法对表达式的求值。
### 5.4.6.1 链接操作
### 5.4.6.2 括号
### 5.4.6.3 闭包
### 5.4.6.4 或表达式
命题R 构造长度为M的正则表达式对应的NFA所需时间最坏情况下与M成正比

建立图上的算法


      
