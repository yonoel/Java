# 单词查找树
+ 查找命中所需时间和被查找的键的长度成正比
+ 查找未命中只需检查若干字符
                        
                        以字符串为键的符号表的API
        public          class           StringST<Value>
                        void            put(String key,Value val)
                        Value           get(String key)
                        void            delete(String key)
                        String          longestPrefixof(String s)
                        Iterable<String> keysWithPrefix(String s)
                        Iterable<String> keysThatMatch(String s)
## 5.2.1 单词查找树
### 5.2.1.1 基本性质
查找树也是由链接的节点组成的数据结构，链接可能为空，也可能只需别的节点，每个节点
只能有一个指向它的节点，称为父节点，还有一个根节点唯一。每个节点都有R条链接，
R为字母表的大小。单词查找树一般含有大量空链接。每条链接对应一个字符，节点表示一个值。
具体来说，我们将每个键所关联的值保存在该键最后一个字母所对应的节点中。

+ 值为空的节点在符号表里没有对应的键，他的存在是为了方便查找。
### 5.2.1.2 查找操作
以键的字符为导向，因为树里包含里所有字符的链接，所以直到走完这个键，会遇到一个空
节点或者，空链接，有以下情况：
+ 键的尾字符所对应的节点中的值非空，命中
+ 键的尾字符所对应的节点中值为空，未命中
+ 查找结束于一条空链接，未命中

### 5.2.1.3 插入
和二叉树一样，插入前要进行次查找，会出现以下情况
+ 在到达尾字符之前就遇到空链接，需要创建新的节点来保存值
+ 在遇到空链接之前达到来尾字符，保存值。
### 5.2.1.4 节点的表示
将空链接考虑进来会突出单词树的以下重要性质
+ 每个节点都含有R个链接，对应可能存在的字符
+ 字符和键均隐式地存在数据结构里

数据结构不会存储任何字符串或者字符，他保存了链接数组和值。因为参数R的作用的重要性，
所以将基于含有R个字符的字母表的单词查找树称为R向单词查找树。
### 5.2.1.5 大小
有三种实现方式选择
+ 即时实现，用变量存储
+ 更加即时，用节点的变量保存
+ 延时递归实现
### 5.2.1.6 查找所有的键
因为键和字符都是隐式地存在树中，所以这个比较难获取，二叉树查找树里，是用了一个一个队列来保存所有键。
但对于单词树，不仅要找到键，还需要表示出来，用collet方法。
### 5.2.1.7 通配符匹配
### 5.2.1.8 最长前缀
### 5.2.1.9 删除操作
从树中删除键值对的第一步是，找到键对应的顶点并设其为null。
如果该节点含有一个非空的链接，什么也不用做了。但如果全是非空链接，就应当删除这个节点。
而且要递归，如果删除其使得其父节点全为空链接，也要删除。
### 5.2.1.10 字母表
为了处理任意的字母表，修改构造接受字母表对象作为参数
## 5.2.2 单词查找树的性质
命题F 单词查找树的链表结构 和键的插入或删除顺序无关，对于任意的给定的一组键，在单词树里必定唯一。
### 5.2.2.1 最坏情况下查找和插入的界限
命题G 在单词树里查找或者插入一个键，访问数组的次数最多的键的长度加+1
### 5.2.2.2 查找未命中的预期时间期限
命题H 字母表的大小为R,在一棵由N个随机键构造的单词查找树中，未命中查找平均所需检查
的节点数量为 ~lgR

说明一点，查找未命中的成本与键的长度无关。只需要检查几个键就可以了。
### 5.2.2.3 空间
一棵树需要多大空间？

命题 I 一棵单词树的链接总数在 RN 到 RNw 之间，w为键的平均长度。

证明，在单词树中，每个键都有一个对于的节点保存关联的值，同时每个节点也有R条链接，
因此至少 RN 条链接总数。如果所有键的首字母不同，那么每个字母都有一个对应节点，
因此是 RNw。

+ 当所有键较短，链接总数接近 RN
+ 当所有键较长，链接总数接近 RNw
+ 缩小R能节省大量空间
                
                        典型的单词查找树的空间需求
        应用              典型的键            平均长度w           字母表大小R              100万个键所构造的单词查找树中的总链接
        加利福尼亚车牌     4PGC938                 7                   256                    二亿多
        数字账号          21465165151515151       20                256/10                       40亿/2亿
        URL              www.baidu.com          17                  256                     40亿
        文本处理            seaesad             11                  256                     2亿
        基因组             ACTG                8                   4                       40亿
       
### 5.2.2.4 单向分支
长键在树中占用了大量空间。可以优化，但是意义不大。如果空间够，单词查找树的性能非常好。

## 5.2.3 三向单词查找树
为了避免R向单词查找树过度的空间消耗，三向单词查找树TST ，每个节点都含有
一个字符，三条链接和一个值。

查找和插入
### 5.2.4 三向单词查找树的性质
#### 5.2.4.1 空间
命题J 由N个平均长度为w的字符串构造的三向单词查找树中的链接总数在 3N 到 3Nw 之间。
#### 5.2.4.2 查找成本
要计算三向单词查找树中的查找和插入操作的成本，需要将它对应的查找成本乘以
遍历每个节点的树的所需成本。

命题K 在一棵由N个随机字符串构造的三向单词查找树中，查找未命中 平均需要比较字符 ~lnN 次。
除 ~lnN 次外，一次插入或命中的查找 会比较 一次被查找的键中的每个字符
#### 5.2.4.3 字母表
可以不必用字母表
#### 5.2.4.4 前缀匹配，查找所有键和通配符匹配
自己写
#### 5.2.4.5 删除
自己写
#### 5.2.4.6 混合三向单词查找树
改进查找方式，使用一个大型显式的多向根节点。维护一张含有R棵 三向单词查找树
的表，每一棵树对应着的键的首字母的一种可能值。如果R不大，使用键的头两个字母。
#### 5.2.4.7 单向分支
和查找树一样，也可以通过将键的尾字母 变为 叶子节点 并在内部节点中
消除单向分支来提高三向单词查找树的空间利用率。

命题L 由N个随机字符串构造的根节点进行了 R^t 向分支 且不含有外部单向分支
的三向单词查找树中，一次插入或者查找 平均需要 lnN-tlnR 次比较
## 5.2.5 应该使用字符串号表的哪种实现
如果空间足够，R向单词查找树的速度是最快的，能够在常数次字符比较完成查找。

对于大型字母表，R向单词树的空间不够，就使用了三向查找树，对字符比较次数是对数级别的比较，而
二叉树中的键的比较次数是对数级别。

                                    各种字符串查找算法的性能特点
                             处理大小为R的字母表构造的N个字符串（平均长度为w）             
        算法                     未命中检查的字符数量             内存使用                优点       
        二叉树                     c(lgN)^2                        64N             适用于随机排列的键
        红黑树                                                                     有性能保证
        线性探测（并行数组）              w                       32N-128N            内置类型
        R向单词查找树                lgN                       （8R+56）N ~(8R+56)Nw 适用于较短的键和较小的字母表
        三向单词查找树              1.39lgN                    64N ~ 64Nw          适用于非随机的键                 
                            
 
       



