# 子字符串查找
## 5.3.1 历史简介
## 5.3.2 暴力查找
命题M 在最坏情况下，暴力解法在长度为N的文本中查找长度为M的pattern需要 ～NM次比较

当然这种奇怪的文本一般不会出现，但在二进制文本中可能出现。
## 5.3.3 Knuth-Morris-pratt 子字符串查找
假设只有AB两个字母，pattern =  B A A A A A A A A A;txt=A B A A A A B A
假设匹配了前5个，第6个失败，暴力算法是回退，继续匹配第二个字符，但其实这里文本指针i不需要回退，
因为前4个都是A ，没有一个匹配。另外i当前指向的B 又与pattern的第一个匹配，所以可以
直接令i+1，从这里开始，说明对于这个pattern可以直接将暴力
子字符串查找算法实现中的else语句替换为 j = 1。 以上的情况比较特殊，但是值得思考。
此算法的基础思想就在于此，不使i回退，根据已知的txt信息来提前判断如何（在哪）重新开始查找。

类似的，在匹配失败时，如果模板中开头部分和文本失败的部分有相同的，就不能跳过所有已经匹配过的字符。

KMP算法在于提前判断从哪开始匹配，而这个提前的因素全取决于pattern

### 5.3.3.1 模式指针J的回退
至此我们可以大概看出一点端倪，当匹配失败时，j要回退的下一个位置k。
存在着这样的性质：pattern最前面的k个字符和txt里j之前的k个字符是一致的，前缀相同
公式： P[0 ~ k-1] == P[j-k ~ j-1]
    
    当T[i] != P[j]时

    有T[i-j ~ i-1] == P[0 ~ j-1]，即存在匹配的部分里，k<j

    如果有P[0 ~ k-1] == P[j-k ~ j-1]

    必然：T[i-k ~ i-1] == P[j-k ~ j-1] == P[0 ~ k-1]
    
    
    对于这个k，我们用next数组来存储（next[j] == k） 那么这个next数组就是存储了这个子串最长的相同前缀后缀的长度
    
    前缀：指的是字符串的子串中从原串最前面开始的子串，如abcdef的前缀有：a,ab,abc,abcd,abcde
    后缀：指的是字符串的子串中在原串结尾处结尾的子串，如abcdef的后缀有：f,ef,def,cdef,bcdef
    例如字符串aababaaba的相同前缀后缀有a和aaba，那么其中最长的就是aaba。
    
    pat=   a b a a b b a b a a b
    next=  0 0 1 1 2 0 1 2 3 4 5
    
    辣么问题来了，怎么构造这个next数组，这也是这个算法巧妙的地方，它用自身pat构造了pat
    for (int i=1;i<m;i++)
    {
        int j=F[i-1];
        while ((B[j+1]!=B[i])&&(j>=0))
            j=F[j];
        if (B[j+1]==B[i])
            F[i]=j+1;
        else
            F[i]=-1;
    }
    1.F[0]=-1　(虽说这里应该是０，但为了方便判越界，同时为了方便判断第０位与第i位，程序中这里置为-1)
    2.这是一个从前往后的线性推导，所以在计算F[i]时可以保证F[0]~F[i-1]都是已经计算出来的了
    3.若以某一位结尾的子串不存在相同的前缀和后缀，这个位的F置为-1（这里置为-1的原因同第一条一样）
    4.!!! F[i]=0 表示 最长相同前缀后缀长度为１，即真实的最长相同前缀后缀＝F[i]+1。(重要的内容要放大) 
    为什么要这样设置呢，因为这时F[i]代表的就不仅仅与前后缀长度有关了，它还代表着这个前缀的最后一个字符在子串B中的位置。
    so，这个还要变
    pat=   a  b  a a b  b a b a a b
    next=  -1 -1 0 0 1 -1 0 1 2 3 4
    再强调一遍，我们这样求出来的F值是该最长相同前缀后缀中的前缀的结束字符的数组位置（从０开始编号）
    ，如果要求最长相同前缀后缀的长度，要输出F[i]+1。
    那么，我们同样可以推出，求解F的思路是：看F[i-1]这个最长相同前缀后缀的后面是否可以接i，若可以，则直接接上，
    举个例子：
    还是以B=”abaabbabaab”为例，我们看到3。
    B=”a b a a b b a b a a b”
    F= -1 -1
    此时这个a的前一个b的F值(j)为-1，所以此时a不能接在b的后面（b的相同最长前缀后缀是０啊），
    此时，j=-1，所以我们判断B[j+1]与B[2]，即B[0](a)与B[2](a)是否一样。一样，
    所以F[2]=j+1=0（代表前0~2字符的最长相同前缀后缀的前缀结束处是B[0],长度为0+1=1）。
    
    再来看到4：
    B=”a b a a b b a b a a b”
    F=-1 -1 0
    j=F[3-1]=0，我们发现B[j+1=1](b)!=B[i=3](a)不能接上i，所以j=F[j]=-1,
    此时B[j+1=0](a)==B[i=3](a)，所以F[3]=j+1=0。
    
    最后举个例子，看到5
    
    B=”a b a a b b a b a a b”
    F=-1 -1 0 0 
    
    j首先=F[4-1]=0，我们看到B[j+1=1]==B[i]，所以F[i]=j+1=1。
    
     B=”a b a a b  b  a  b a a b”
     F= -1 -1 0 0 1 -1 0  1 2 3 4
     
     **** 使用pat和自身匹配构造了这个f数组来保存  最长相同前缀后缀的长度
        
    我们发现一个规律：
    
        当P[k] == P[j]时，
        
        有next[j+1] == next[j] + 1
    
    其实这个是可以证明的：
    
    因为在P[j]之前已经有P[0 ~ k-1] == p[j-k ~ j-1]。
    
    这时候现有P[k] == P[j]，我们是不是可以得到P[0 ~ k-1] + P[k] == p[j-k ~ j-1] + P[j]。
    
    即：P[0 ~ k] == P[j-k ~ j]，即next[j+1] == k + 1 == next[j] + 1。
    
    当 P[k] != P[j]时,此时说明出现了不匹配，应当回退，辣么回退的的值应该是next[j] == k,
     
    
    


KMP不控制文本指针 i ，而利用控制模式指针j的回退来实现算法的优化，
利用一个数组 dfa[][]来记录匹配失败时 指针j的回退多少。（DFA存储了匹配以后的回退记录，）
1. 对于每个字符c，比较了c和pat.charAt(j)(就是从pat里提取出来的那个字符)以后，dfa[c][j]
存储了应该和下个文本字符比较的 pattern 字符的位置。
2. 在查找中，dfs[txt.charAt(i)][j]存储了 比较txt.charAt(i) 和pat.charAt(j)
之后和txt.charAt(i+1) （下一个文本字符）比较的 pattern的字符位置。

因此 dfa[pat.charAt(j)][j] 总是 j+1

### 5.3.3.2 KMP 查找算法
### 5.3.3.3 DFA 模拟
DFA（有限状态自动机）

在查找中，从文本头开始读取，起始状态为0，停留在0 扫描文本，然后遇到一个首字母
相同的字符，这是移动到下一个状态+1。每找到一个匹配，状态都向下移动+1直到m=pat.length，失败会回退
到之前的状态。

### 5.3.3.4 构造 DFA
问题关键就是构造DF。利用自身算法构造自身。

当在pat.charAt(j)处匹配失败时，我们已经知道了pat.charAt(1)-pat.charAt(j-1),因为j已经不匹配了
这个pat的子pat是已知的

KMP 算法为最坏情况提供了线性的运行时间。但实际应用中并不十分明显，因为
极少有应用需要在重复性很高但文本中查找重复性很高的pattern。

## 5.3.4 Boyer-Moore 字符串查找算法
当可以在文本字符串中回退时，如果从右向左扫描pattern，并将这个和文本匹配，就得到了一种快速的算法。
比如，pat是BABBBAA时，如果7，6匹配，但是第五个不匹配，直接就向右侧移动7个位置，当然这是因为匹配的是XAA
这三个字符在pat里是唯一的。

Boyer-Moore给出的另一种从右向左扫描的实现。

### 5.3.4.1 启发式的处理不匹配的字符
把字符串当作整体来匹配，直接偏移，然后从右向左匹配，偏移每次匹配的位置。
在字符串 F I N D I N A H A Y S  
### 5.3.4.2 起点
利用一个数组right来记录字母表中每个字符在模式中出现最靠右的地方（如果字符在
模式中不存在表示-1）。这个值揭示了每次的偏移量。
。。。 这一章都比较复杂，需要慢慢看