# 子字符串查找
## 5.3.1 历史简介
## 5.3.2 暴力查找
命题M 在最坏情况下，暴力解法在长度为N的文本中查找长度为M的pattern需要 ～NM次比较

当然这种奇怪的文本一般不会出现，但在二进制文本中可能出现。
## 5.3.3 Knuth-Morris-pratt 子字符串查找
假设只有AB两个字母，pattern =  B A A A A A A A A A;txt=A B A A A A B A
假设匹配了前5个，第6个失败，暴力算法是回退，继续匹配第二个字符，但其实这里文本指针i不需要回退，
因为前4个都是A ，没有一个匹配。另外i当前指向的B 又与pattern的第一个匹配，所以可以
直接令i+1，从这里开始，说明对于这个pattern可以直接将暴力
子字符串查找算法实现中的else语句替换为 j = 1。 以上的情况比较特殊，但是值得思考。
此算法的基础思想就在于此，不使i回退，根据已知的txt信息来提前判断如何（在哪）重新开始查找。

类似的，在匹配失败时，如果模板中开头部分和文本失败的部分有相同的，就不能跳过所有已经匹配过的字符。

KMP算法在于提前判断从哪开始匹配，而这个提前的因素全取决于pattern

### 5.3.3.1 模式指针J的回退
至此我们可以大概看出一点端倪，当匹配失败时，j要回退的下一个位置k。
存在着这样的性质：pattern最前面的k个字符和txt里j之前的k个字符是一致的，前缀相同
公式： P[0 ~ k-1] == P[j-k ~ j-1]
    
    当T[i] != P[j]时

    有T[i-j ~ i-1] == P[0 ~ j-1]，即存在匹配的部分里，k<j

    如果有P[0 ~ k-1] == P[j-k ~ j-1]

    必然：T[i-k ~ i-1] == P[j-k ~ j-1] == P[0 ~ k-1]
    
    
    对于这个k，我们用next数组来存储（next[j] == k） 那么这个next数组就是存储了这个子串最长的相同前缀后缀的长度
    
    前缀：指的是字符串的子串中从原串最前面开始的子串，如abcdef的前缀有：a,ab,abc,abcd,abcde
    后缀：指的是字符串的子串中在原串结尾处结尾的子串，如abcdef的后缀有：f,ef,def,cdef,bcdef
    例如字符串aababaaba的相同前缀后缀有a和aaba，那么其中最长的就是aaba。
    
    pat=   a b a a b b a b a a b
    next=  0 0 1 1 2 0 1 2 3 4 5
    
    辣么问题来了，怎么构造这个next数组，这也是这个算法巧妙的地方，它用自身pat构造了pat
    for (int i=1;i<m;i++)
    {
        int j=F[i-1];
        while ((B[j+1]!=B[i])&&(j>=0))
            j=F[j];
        if (B[j+1]==B[i])
            F[i]=j+1;
        else
            F[i]=-1;
    }
    1.F[0]=-1　(虽说这里应该是０，但为了方便判越界，同时为了方便判断第０位与第i位，程序中这里置为-1)
    2.这是一个从前往后的线性推导，所以在计算F[i]时可以保证F[0]~F[i-1]都是已经计算出来的了
    3.若以某一位结尾的子串不存在相同的前缀和后缀，这个位的F置为-1（这里置为-1的原因同第一条一样）
    4.!!! F[i]=0 表示 最长相同前缀后缀长度为１，即真实的最长相同前缀后缀＝F[i]+1。(重要的内容要放大) 
    为什么要这样设置呢，因为这时F[i]代表的就不仅仅与前后缀长度有关了，它还代表着这个前缀的最后一个字符在子串B中的位置。
    so，这个还要变
    pat=   a  b  a a b  b a b a a b
    next=  -1 -1 0 0 1 -1 0 1 2 3 4
    再强调一遍，我们这样求出来的F值是该最长相同前缀后缀中的前缀的结束字符的数组位置（从０开始编号）
    ，如果要求最长相同前缀后缀的长度，要输出F[i]+1。
    那么，我们同样可以推出，求解F的思路是：看F[i-1]这个最长相同前缀后缀的后面是否可以接i，若可以，则直接接上，
    举个例子：
    还是以B=”abaabbabaab”为例，我们看到3。
    B=”a b a a b b a b a a b”
    F= -1 -1
    此时这个a的前一个b的F值(j)为-1，所以此时a不能接在b的后面（b的相同最长前缀后缀是０啊），
    此时，j=-1，所以我们判断B[j+1]与B[2]，即B[0](a)与B[2](a)是否一样。一样，
    所以F[2]=j+1=0（代表前0~2字符的最长相同前缀后缀的前缀结束处是B[0],长度为0+1=1）。
    
    再来看到4：
    B=”a b a a b b a b a a b”
    F=-1 -1 0
    j=F[3-1]=0，我们发现B[j+1=1](b)!=B[i=3](a)不能接上i，所以j=F[j]=-1,
    此时B[j+1=0](a)==B[i=3](a)，所以F[3]=j+1=0。
    
    最后举个例子，看到5
    
    B=”a b a a b b a b a a b”
    F=-1 -1 0 0 
    
    j首先=F[4-1]=0，我们看到B[j+1=1]==B[i]，所以F[i]=j+1=1。
    
     B=”a b a a b  b  a  b a a b”
     F= -1 -1 0 0 1 -1 0  1 2 3 4
     
     **** 使用pat和自身匹配构造了这个f数组来保存  最长相同前缀后缀的长度
        
    我们发现一个规律：
    
        当P[k] == P[j]时，
        
        有next[j+1] == next[j] + 1
    
    其实这个是可以证明的：
    
    因为在P[j]之前已经有P[0 ~ k-1] == p[j-k ~ j-1]。
    
    这时候现有P[k] == P[j]，我们是不是可以得到P[0 ~ k-1] + P[k] == p[j-k ~ j-1] + P[j]。
    
    即：P[0 ~ k] == P[j-k ~ j]，即next[j+1] == k + 1 == next[j] + 1。
    
    当 P[k] != P[j]时,此时说明出现了不匹配，应当回退，辣么回退的的值应该是next[j] == k,
     
    
    


KMP不控制文本指针 i ，而利用控制模式指针j的回退来实现算法的优化，
利用一个数组 dfa[][]来记录匹配失败时 指针j的回退多少。（DFA存储了匹配以后的回退记录，）
1. 对于每个字符c，比较了c和pat.charAt(j)(就是从pat里提取出来的那个字符)以后，dfa[c][j]
存储了应该和下个文本字符比较的 pattern 字符的位置。
2. 在查找中，dfs[txt.charAt(i)][j]存储了 比较txt.charAt(i) 和pat.charAt(j)
之后和txt.charAt(i+1) （下一个文本字符）比较的 pattern的字符位置。

因此 dfa[pat.charAt(j)][j] 总是 j+1

### 5.3.3.2 KMP 查找算法
### 5.3.3.3 DFA 模拟
DFA（有限状态自动机）

在查找中，从文本头开始读取，起始状态为0，停留在0 扫描文本，然后遇到一个首字母
相同的字符，这是移动到下一个状态+1。每找到一个匹配，状态都向下移动+1直到m=pat.length，失败会回退
到之前的状态。

### 5.3.3.4 构造 DFA
问题关键就是构造DF。利用自身算法构造自身。

当在pat.charAt(j)处匹配失败时，我们已经知道了pat.charAt(1)-pat.charAt(j-1),因为j已经不匹配了
这个pat的子pat是已知的

KMP 算法为最坏情况提供了线性的运行时间。但实际应用中并不十分明显，因为
极少有应用需要在重复性很高但文本中查找重复性很高的pattern。

## 5.3.4 Boyer-Moore 字符串查找算法
当可以在文本字符串中回退时，如果从右向左扫描pattern，并将这个和文本匹配，就得到了一种快速的算法。
比如，pat是BABBBAA时，如果7，6匹配，但是第五个不匹配，直接就向右侧移动7个位置，当然这是因为匹配的是XAA
这三个字符在pat里是唯一的。

Boyer-Moore给出的另一种从右向左扫描的实现。

### 5.3.4.1 启发式的处理不匹配的字符
把字符串当作整体来匹配，直接偏移，然后从右向左匹配，偏移每次匹配的位置。
在字符串 F I N D I N A H A Y S T A C K N E E D L E中查找N E E D L E 。
一开始就从第五个开始，然后因为N出现在了子串里，所以将文本里的N和模式的N对齐，即向右移动5。
然后比较尾E和文本的，失败，直接右移6个位置。
在从右侧开始匹配，然后发现15个位置N和模式不匹配，再右移5个位置
再从右侧开始匹配，配对成功。

仅用了4次字符比较，6次模版比较


### 5.3.4.2 起点
利用一个数组right来记录字母表中每个字符在模式中出现最靠右的地方（模式中不存在表示-1）。
这个值揭示了如果该字符出现在文本且查找失败时，向右边跳跃的距离。
### 5.3.4.3 子字符串的查找
用i表示文本的下标，用j表示模式中从右向左的下标,自然排序，外循环整个文本，内循环匹配如果从M-1到0（J的范围）都有pat.charAt(j) == txt.charAt(i+j),则配对成功。

配对失败有以下几种情况
1. 如果失败的字符不在模式里，则要将模式向右移动 j+ 1（因为0也是个下标） 个位置，也就是 i+j+1,此时right[txt.charAt(i+j)] = -1;
此处也可以用kmp类似的状态机来保存使得这个偏移量更大。
2. 如果失败的字符包含在模式里，则要使用right数组里的值即index，使模式字符串和文本对齐，i + j - right[txt.charAt(i+j)] -》该字符和它在模式里最右边的位置对齐,此时right[txt.charAt(i+j)] = rightIndex；
然后重置j = M-1；
此处也可以用kmp类似的状态机来保存使得这个偏移量更大。
3. 如果失败的字符包含在模式里，但无法使i变大，没有意义，必须要向右移动，则令 i + 1：
(比如txt里是XXXXXELE,当匹配到第二个E时，此时j(3)指向D，不匹配,,此时right[txt.charAt(i+j)] = rightIndex，若对齐LE和模式的LE ，那便是向左偏移，没有意义)
，因此令j=M - 1 也就是让i+1,此处也可以用kmp类似的状态机来保存使得这个偏移量更大。

使用-1表示不存在在pat里的值，这种约定能将前2种情况合并（将i+ (j - right[txt.charAr(i+j)]）) 
```
    证明 skip = j - right[c]
   1:移动 j + 1 ,因为right[c] = -1 ，所以相等
   2:移动 j - right[c],
   3:此时 skip < 0 ,因为 j< right[c] ，令skip = 1 
```
## 5.3.5 Rabin-Karp 指纹字符串查找算法
这是一种基于hash的查找算法。先计算pat的hash值，再计算txt的所有可能的M个字符的子串的hash值，然后配对。根据哈希值，先找到子串，再去一个个匹配。等价于
生成一个基于pat的散列表，但不需要留有空间，因为只有这一个元素。当然根据描述直接实现的算法会比暴力查找还慢。

Robin和Karp发明了一种在常数时间里算出M个字符的子串的hash值的方法，最终查找只需要线性时间
### 5.3.5.1 基本思想
长度为M的字符串对应着一个R进制的M位数，用Q大小的散列表来存储这种类型的键，需要将M位数转为0 - Q-1 之间的int值作为键存储。这个转换的函数我们选择用
取余数的方法,Q取一个很大的素数。

举例子：在文本 3 1 4 1 5 9 2 6 5 3 5 8 9 7 9 3 找 2 6 5 3 5 ，那么值便是 26535 % 997 = 613
### 5.3.5.2 计算散列函数
对于一个5位的树枝，用int值就可以了，但M是百位甚至千位怎么办，这里用了一个horner方法
```
    private long hash(String key, int M) {
        //计算 key[0...M-1]的hash值
        long h = 0;
        for (int i = 0; i < M; i++) {
            h = (R * h + key.charAt(i)) % Q;
        }
        return h;
    }

        pat.charAt(i)
        
    i 0 1 2 3 4 
      2 6 5 3 5
    0 2 %997 =2
    1 2 6 %997 = (2*10+6)%997 = 26
    2 2 6 5 %997 =(26*10+5)%997 =265
    3 2 6 5 3 %997 =(265*10+3)%997 = 613
    4 2 6 5 3 5 %997 =(613*10+5) %997 = 613 
```
这个算法的成本中包括了，将文本的每个字符乘法，加法，取余，最坏情况下需要NM次操作，相比较暴力算法没有区别
### 5.3.5.3 关键思想
Robin-karp算法的基础是对于所有位置i，高效计算文本中 i+1位置的子字符串值。
```
    假设模式字符串的长度为m，利用
    Horner法则
    p = p[m] + 10(p[m -1] + 10(p[m-2]+...+10(p[2]+10p[1])...))
    
    对应于每个长度为m的子串的哈稀值为t(s+1)=10(t(s)-10^(m-1)T[s+1])+T[s+m+1]，
    
    
   ti = txt.charAt(i)
   那么文本txt中起始于i的含有M个字符的子字符串所对应的数为 xi = tiR(M-1)+ t(i+1)R(M-2)+....+t(i+M-i)R(0)
   又可知 h(xi) = xi mod Q
   又可知 x (i+1) = (xi-tiR(M-1))R + t(i+m+1)

```
### 5.3.5.4 实现
构造函数计算patHash值，并在变量RM保存了 R（M-1） mod Q的值。而search方法计算文本的前M个字符的散列值并且和patHash比较，然后如此往复。
### 5.3.5.5 小技巧：蒙特卡洛验证正确性
在文本txt中找到散列值与模式字符串匹配的一个M个字符的子字符串后，你可能想逐个比较每个字符。但是我们不打算这么做，
作为替代，将散列表的"规模"Q设为任意大的一个值，我们并不会真构造一个散列表，而只是希望用pat验证是否会产生冲突，取一个大于10(20)的long值。
使一个随机键和pat冲突的概率小于10（-20）。这就是蒙特卡洛算法的早期应用。检查匹配的其他方法可能很慢（性能有很小的概率相当于暴力算法）但能确保正确性，这种算法被成为拉斯维加斯算法。
## 5.3.6 总结
        表 5.3.2 各种字符串查找算法的实现的总结
                                            操作次数
    算法              版本              最坏       一般     在文本中回退          正确性     额外的空间需求
    暴力                                MN        1.1N        是               是           1
    KMP             完整的DFA           2N        1.1N        否                是           MR
                  仅仅构造不匹配的状态     3N        1.1N        否                是           M
                    完整                  3N        N/M         是               是           R
    BM              启发式             MN          N/M         是               是           R
    Robin           蒙特卡洛           7N          7N          否                是           1
                    拉斯维加斯          7N          7N          是                是           1    