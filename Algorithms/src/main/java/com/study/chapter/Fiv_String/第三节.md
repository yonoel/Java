# 子字符串查找
## 5.3.1 历史简介
## 5.3.2 暴力查找
命题M 在最坏情况下，暴力解法在长度为N的文本中查找长度为M的pattern需要 ～NM次比较

当然这种奇怪的文本一般不会出现，但在二进制文本中可能出现。
## 5.3.3 Knuth-Morris-pratt 子字符串查找
假设只有AB两个字母，pattern =  B A A A A A A A A A;
假设匹配了前5个，第6个失败，暴力算法是回退，继续匹配第二个字符，但其实不需要回退，
因为前4个都是A ，没有一个匹配。另外i当前指向的B 又与pattern的第一个匹配，所以可以
直接令i+1，从这里开始，说明对于这个pattern可以直接将暴力
子字符串查找算法实现中的else语句替换为 j = 1。 以上的情况比较特殊，但是值得思考。
此算法的基础思想就在于此，不使i回退，提前判断如何重新开始查找。
### 5.3.3.1 模式指针J的回退
利用一个数组 dfa[][]来记录匹配失败时 指针j的回退多少。
对于每个字符c，比较了c(txt.charAt(i))和pat.charAt(j)以后，dfa[c][j]
表示应该和下个去和 文本字符比较的 pattern 字符的位置。
在查找中，dfs[txt.charAt(i)][j]是在比较了txt.charAt(i)和pat.charAt(j)
之后和txt.charAt(i+1) 比较的 pattern的字符位置
### 5.3.3.2 KMP 查找算法
### 5.3.3.3 DFA 模拟
DFA（有限状态自动机）

在查找中，从文本头开始读取，起始状态为0，停留在0 扫描文本，然后遇到一个首字母
相同的字符，这是移动到下一个状态。每找到一个匹配，状态都向下移动直到，失败会回退
到之前的状态。

### 5.3.3.4 构造 DFA
问题关键就是构造DF。

KMP 算法为最坏情况提供了线性几杯的运行时间。但实际应用中并不十分明显，因为
极少有应用需要在重复性很高但文本中查找重复性很高的pattern。

## 5.3.4 Boyer-Moore 字符串查找算法
如果回退的时候，从右向左扫描pattern，并将这个和文本匹配，就得到了一种快速的算法。

### 5.3.4.1 启发式的处理不匹配的字符
把字符串当作整体来匹配，直接偏移，然后从右向左匹配，偏移每次匹配的位置。
### 5.3.4.2 起点
利用一个数组right来记录字母表中每个字符在模式中出现最靠右的地方（如果字符在
模式中不存在表示-1）。这个值揭示了每次的偏移量。
。。。 这一章都比较复杂，需要慢慢看