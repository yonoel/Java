# JAVA 内存区域与内存溢出

## 概述

### 运行时数据区域

JVM在执行app时会把他管理的内存划分为若干个不同的数据区域。每个区域都有各自的用途，以及创建，和销毁时间。

根据《JVM规范第七版》，JVM管理的内存包括以下几个运行时数据区域

+   方法区 Method Area
+   堆   Heap
+   虚拟机栈    VM Stack
+   本地方法栈   Native Method Stack
+   程序计数器   Program Counter Register

方法区和堆由所有线程共享，其他三块是线程隔离的数据区

### 程序计数器

程序计数器是一块较小的内存空间，可以看作是当前线程执行的字节码的行号指示器。字节码解释器工作时通过改变这个计数器的值来选取下一条需要执行的字节码指令，
比如分之，循环，异常处理等。

由于JVM的多线程是通过线程切换并分配处理器执行来实现的，在任何一个确定的时刻，一个处理器都只会执行一条线程中的指令。因此，为了线程切换后能恢复到正确
的执行位置，需要这样一个独立的线程计数器。（线程私有）

注意，如果执行的是Native方法，则计数器值为undefined。这块内存区域是唯一一个在JVM规范里没有规定outOfMemory的区域。

### 虚拟机栈 VM Stack

虚拟机栈也是线程私有的，它的生命周期和线程相同。

虚拟机栈描述的是java方法执行的内存模型：每个方法在执行的同时创建一个Stack Frame，用于存储局部变量等信息。

每一个方法从调用到执行完毕，都对应着一个StackFrame在Vm Stack里的入栈和出栈。

局部变量表所需内存空间在编译期间就已经完成，在运行期间不会更改。

JVM内存规范里规定了两种异常：
1.  如果线程请求的栈深度大于虚拟机所允许的深度，抛出StackOverFlow
2.  如果虚拟机栈可以动态扩展（大部分是可以的，但也可以固定长度），如果扩展时无法申请到足够的内存，抛出OutOfMemory

### 本地方法栈 Native Method Stack

和VM stack相似，区别就是执行的方法不同。因此抛出的异常也相同。

### 堆 Heap

Heap是JVM管理内存中最大的一部分，是所有线程共享的区域。在JVM启动时创建，目的在于存放对象实例。

规范是这么写的：所有对象实例以及数组都在堆上分配。当然不是那么绝对。

Heap也是GC的主要区域，也被称为GC堆。从内存回收角度来看，由于现在都基于分代收集法，因此细分为：新生代，老年代，再细致一点有Eden，FromSurvivor，
ToSurvivor。

从内存分配来看，线程共享的堆可以划分出多个私有私有的分配缓冲区（TLAB thread local allocation buffer）。

根据规范，heap可以处于物理上不连续的内存空间中，只要逻辑连续即可。当前主流是配置成可扩展的即（-Xmx -Xms）。

若无法扩展时，抛出OutOfMemory

### 方法区Native Method

和Heap一样也是线程共享的内存区域，用于存储已被虚拟机加载的类信息，常量，静态变量等，即时编译器后的代码等数据。

规范把方法区描述为堆的一个逻辑部分，但是别名却是Non-Heap。对方法区的限制十分宽松，可以选择不回收垃圾。类似"永生"，但其实只是条件十分苛刻。
会抛出OutOfMemory

### 运行时常量池 Runtime Constant Pool

方法区的一部分，用于存放编译期生成的各种字面量和符号引用。

运行时常量池具备动态性，并不要求常量一定只有编译期才能生产。比如String的intern方法。
会抛出OutOfMemory

### 直接内存 Direct Memory

直接内存并不是虚拟机运行时数据区的一部分，也不是规范中定义的内存区域，但是这部分也会被频繁使用，会抛出OutOfMemory。

NIO流，基于通道和Buffer，可以使用Native方法，直接分配堆外内存，然后通过java堆里的DirectByteBuffer对象作为对这块内存的引用来进行操作，能显著
提高性能，避免了在Native Heap和JavaHeap中来回复制。

受到本机总内存Ram以及Swap区域等影响。

## HotSpot虚拟机对象

### 对象的创建

虚拟机接到一条new指令，首先检查这个指令的参数是否能在常量池定位到一个类的符号引用，并且检查这个符号引用代表的类是否被加载，解析，初始化。若没有执行，类加载。（类加载检查）
接下来为新生对象分配内存。

分配内存的方式（由垃圾回收算法决定）：
1.  指针碰撞 bump the pointer若内存是规整的连续的一块，则只需要把指针向空闲区域移动所需的空间。
2.  空闲列表 free list，非规整的区域，虚拟机维护一个list，记录哪些可用，哪些不可用。（通常是这种）

创建对象的空间是否是频繁行为？比如正在给A划开空间，又对B划开了相同的空间。解决方案：
1.  同步代码块，虚拟机用的是cas操作
2.  把分配的动作按照线程划分在不同的空间中进行，即TLAB线程本地收集缓冲区，由 -XX:+/-UseTLAB决定

分配完成后，把内存空间初始化，保证了对象有些字段不被赋值也能使用默认值。接下来对对象进行必要的设置，比如哈希，元数据信息。

此时对于虚拟机，对象已经创建完毕，对于java程序来说，对象才刚刚开始创建，init方法还没有执行。

### 对象的内存布局

对象在内存中的存储布局分为三块
1.  对象头 header 
    1.  存储对象自身的运行信息，哈希，gc年龄，锁等 Mark Word
    2.  类型指针,数组的话还有块数组长度的数据
2.  实例数据    Instance Data
3.  填充  Padding 不必然存在，起到占位符的作用，因为对象的起始位置必须是八字节的整数倍，即对象的大小必须是八字节的整数倍，而对象头正好是32bit或者64bit，正好是倍数，
但是实例不一定是倍数，因此需要填充。

### 对象的访问定位

通过栈上的Reference来操作堆上的具体对象，规范只规定了一个指向对象的引用，并没有说明如何引用，因此这一块由虚拟机决定：
1.  使用句柄访问，堆中会有一块句柄池，优势是对象的实例指针会改变，而类本身不该，即Reference不改变。
2.  直接用指针 （就要考虑类型信息放在哪里），优势是速度块

## 实例：outOfMemory异常

### 堆溢出

见HeapOOM

一般手段是通过内存snapshot，确定是内存里的对象是否是必要的，即是出现了内存泄漏还是内存溢出。

泄漏可以查到为何，无法GC

如果是内存溢出，检查堆参数等处理手段。

### 虚拟机栈和本地方法栈溢出

规范了两种异常：
1.   超过最大深度，stackOverFlow
2.  oufOfMemory

两者其实有点重叠，难以区分

见JavaVMStackSOF,单线程测试下，无论是由于栈太浅，还是容量太少，都抛出SOF
1.  使用Xss参数减少内存容量，理应抛内存溢出
2.  不使用xss参数，增大这个本地变量值，增加调用深度，理应抛SOF

若用多线程测试，能测试出内存溢出。但是这样的内存溢出，与栈空间总大小不存在直接关联，因为，栈空间本身就有限，
多线程以后，每个线程都要一个内存来分配，自然更容易产生内存溢出。
见JavaVMStackOOM

StackOverFLow有错误堆栈可读，比较容易找到问题，其次默认栈深度在1000-2000之间是没有问题的，够用了。但若是由多线程导致的内存溢出，那解决方案要么
减少线程数更换64位的机器，要么减少堆内存或者减少单个栈的容量来换取更多线程。

### 方法区和常量池溢出

String.intern()是一个Native方法，作用是在常量池里找String的常量是否存在，若存在返回，否则新生一个。

见RuntimeConstantPoolOOM，若在jdk1.6里跑，抛内存溢出，PermGen space，JDK7和8可以一直跑下去。。。

在见下面的字符串比对。JDK1.6会抛两个False，JDK7.8第一个false，后面true。
因为intern在JDK1.6里会把首次遇到的实例复制到常量池里，返回实例的引用，而由SB构造的实例在堆上，引用不相同，false。
而后来版本的JDK将不会在复制实例到常量池，只是在常量池保存里实例的引用，因此第二个Python报true，第一个java为false是因为，java在SB构造前就已经常量池里了，不符合首次出现
的原则。

模拟方法区溢出的思路是运行时产生大量的类去填充它，这个在Spring，CGLib，需要增强的类越多，这种信息越多；另外JVM的动态语言如Grovvy会持续创建类来实现语言的动态性。
见JavaMethodAreaOOM
抛出Exception in thread "main" java.lang.OutOfMemoryError: Metaspace

方法区溢出也是常见的溢出，类被回收的判定条件比较苛刻。常见的有JSP大量动态生产，基于OSGI（OSGi（开放服务网关协议，Open Service Gateway Initiative）
技术是Java动态化模块化系统的一系列规范）的应用

### 本机内存溢出

通过-XX:MaxDirectMemorySize指定，若不指定，和Java堆内存一样大即-Xmx
见DirectMemoryOOM

会抛出native方法的错误，或者直接使用了NIO

## 总结

内存划分 

线程共享的：方法区（常量池），堆heap（对象池）
线程独有的：本地方法栈，程序计数器，虚拟机栈
特殊：直接内存









