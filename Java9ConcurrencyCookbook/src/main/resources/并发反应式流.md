# 并发反应式流

+   创建流
+   归约流
+   收集流
+   流上的操作
+   过滤元素
+   转换流
+   排序流
+   验证流
+   在流上编程

## 简介

流的特性
+   流是数据序列，不是数据结构
+   可以从不同的源创造流
+   不能访问流里的单个的元素
+   不能修改流的源
+   流定义了以下两类操作
    +   中间操作：产生新流
    +   结尾操作：处理流里的所有元素
+   一个流由0到多个中间操作和结尾操作组成
+   中间操作有如下状态
    +   无状态，处理流中的一个元素不依赖于流中的其他元素，比如过滤
    +   有状态，比如排序
+   惰性：中间操作是惰性的，在结尾操作之前，中间操作是不会执行的
+   流可以有无限数量的元素
+   流只能用一次
+   开发者可以按顺序处理流

## 创建流

+   Collection接口
+   supplier接口
+   预定义的元素集合
+   文件和目录
+   数组
+   随机数生成器
+   两个不同的流串联
+   其他

## 归约流

MapReduce是一种编程模型，用在分布式集群环境中使用了大量机器处理超大数据集，有如下两类操作：
+   Map，把原始元素过滤转换成一种更适合归约操作的形式
+   Reduce，在所有元素上生产一个总计结果

## 收集流

流的操作分为2类：
+   中间操作，返回一个新的stream，过滤，转换，排序
+   结尾操作，处理完流的所有元素返回一个结果

一个流有一个源，N个中间操作和一个结尾操作。结尾操作有如下两种：
+   归约操作：处理完流里的所有元素后获得唯一结果
+   收集操作：用元素的处理结果生成一种数据结果，由于这种数据结构是可变的，所以这种操作也被称为可变归约操作

## 把一个动作应用到流的每个元素

+   forEach
+   forEachOrdered
+   peek,注意这是一个中间操作，只有当结尾操作执行时，peek里的操作才会执行。

sorted方法必须提供Comparator，或者实现Comparable接口

## 过滤

+   distinct,默认是equals，因为这个操作是有状态的，无法获得并行流的优势
+   filter
+   limit，无序流性能可以，有序流一般
+   skip，同limit

## 转换流中的元素

+   mapTo...
+   map
+   flatMap,注意此方法需要返回一个新的底层的stream，而后自动串联这个流

## 排序流

排序对串行流的性能影响不大，对并行流的性能影响很大。因此为了性能考虑可以采用unOrdered删除顺序，反而能提升性能。
forEach并不考虑顺序。

## 在流上验证条件

## 在反应流上反应式编程ReactiveStream 需要java9


反应式流定义了一种机制，这种机制提供了非阻塞背压的异步流处理方式。
反应式流的三个要素
+   信息发布者
+   一个或多个信息订阅者
+   发布者和消费者之间的订阅

反应式流的规范确定了这些类之间的交互，并遵循如下规则：
+   发布者添加希望通知的订阅者
+   订阅者被添加到发布者时将接收到一个通知
+   订阅者会以异步的方式向发布者请求一个或多个元素，（非阻塞）
+   当发布者有消息发布时，将其通知订阅者




