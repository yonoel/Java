# 线程同步基础

+   方法同步
+   在同步代码块中使用条件
+   在同步代码块使用锁
+   用读/写锁保护同步代码块
+   在一个锁中使用多个条件
+   stampedLock

## 简介

线程间共享资源的情形称为竞态条件。还有可能遇到可见性问题，即线程更改的变量值只对当前的工作线程可见，因此其他线程不可见值的变化。因此提出临界区的概念。
临界区是指一个用于访问共享资源的代码块，并且只能由一个线程执行。java提供了两种基本的临界区机制：
+   synchronized
+   lock接口

## 方法同步

见ParkingCash，ParkingStats，Sensor，synchronized是可以重入的，但是性能不佳。

## 在同步代码块中使用条件

见EventStorage，producer，consumer，wait等待，notify唤醒一个线程

！！！必须不断检查条件并在while里循环执行wait方法，只有当条件满足时才能终止循环。

## 在同步代码块使用锁机制

用Lock的优势
+   构建同步代码更加灵活，关键词仅能作用于一段代码结构块，通过Lock，可以更加复杂的结构
+   有更强的api，比如tryLock
+   读写锁配置

公平与非公平锁的配置差距很大，推荐非公平。见PrintQueue

！！！开发者要妥善处理tryLock，返回false时不该在进入临界区。

小心死锁（锁的顺序）

## 读写锁的使用

见PriceInfo，Reader，Writer，当写锁获取时，所有线程也没法读。读写锁互斥。

## 在一个锁中使用多个条件

介绍Condition，见FileMock

因为Condition都来自一个Lock，在使用condition时必须先获得lock。
当线程调用condition的await时，会释放锁!!!!。(否则不就独占了线程，不会出现生产者和消费者互相拼抢的现象了，应是重用了lock的unlock,但是粒度比他更细)

## StampedLock

StampedLock提供的锁和Lock和ReadWriteLock提供的有所不同，同样也不是两者的实现类，功能类似。主要作用是为构建一个线程安全的组件提供工具类。

主要特征
+   开发可以通过以下几种模式获得锁
    +   写   在该模式下互斥地获得锁
    +   读   可以以"非互斥"地获得锁，不过其他使用写锁和乐观读锁模式的线程不能同时获得同一把锁
    +   乐观锁 在此模式并没有获得锁，其他线程仍能通过读锁获取锁，当用乐观锁保护共享变量时，需要额外检查当前是否可以访问变量或者不使用validate方法
    
提供的方法主要服务以下情况
+   获得上述三种锁的控制权，若使用类内的readLock，writeLoc，readLockInterrupted无法获得锁，当前线程会在获取锁前挂起
+   获得上述三种锁的控制权，若使用类内的tryOptimisticRead,tryReadLock,tryWriteLock无法获得锁，则方法返回表示当前情况的特殊返回值
+   锁模式相互转换，无论成功失败，使用asReadLock，asWriteLock,asReadWriteLock，都将返回结果
+   释放锁

以上所有方法都会返回一个在锁中使用被成为stamp都long返回值，如果返回0，表示失败

StampedLock不是可重入锁，若线程利用次方法再次调用，可能导致阻塞或者死锁

该类型的锁没有所有权概念，一个锁内的线程获取后可能被其他的线程释放？？？

该锁对下一个即将获得锁的线程没有限制

这个明显比lock和读写锁更灵活啊。。。直接封装了尝试锁，锁还能升级，long类型的值相当于一个时间戳来记录当前的锁值







