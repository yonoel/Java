# 结构型模式
## ADAPTER
1. 意图
    将一个类的接口转换成客户希望的另一个接口，使得原本不由于接口不兼容而不能一起工作的类一起工作
2. 别名
    wrapper
3. 动机
    有时，为复用而设计的工具箱类不能被复用的原因仅仅是因为接口不兼容.
    比如，有个绘图编辑器，图形对象的接口为shape的抽象类定义，每种图形都有不同的子类，LineShape，PolygonShape，等等。
    但是TextShape比较难实现，同时工具箱提供类TextView用于显示和编辑文本，理想情况是复用TextView实现TextShape，显然不行，view被封闭了
    
    我们的解决方案只能如下定义TextShape类，适配TextView接口和Shape接口。有两种途径
    1. 继承Shape接口和Text的实现。（多继承）
    2. 将一个TextView的实例作为TextShape的组成部分（成员变量）
    
    这两种方法对应了Adapter模式的类和对象版本，我们将TextShape称之为适配器Adapter
4. 适用性
    以下情况适用Adapter模式
    1. 你想使用一个已经存在的类，而它的接口不符合你的需求
    2. 你想创建一个可以复用的类，该类可以与其他不相关的类或不可预见的类协同工作
    3. （仅适用于适配器对象）你想使用一些已经存在的子类，但是不可能对每一个都进行子类化以匹配它们的接口，对象适配器可以适配它们的父类接口
5. 结构
    1. 类适配器使用多重继承对一个接口和另一个接口进行适配
    2. 对象适配器依赖于对象组合（成员变量）
6. 参与者
    + Target （Shape）
        定义client使用与特定领域相关的接口
    + Client （DrawingEditor）
        与符合Target要求的对象协同工作
    + Adaptee（TextView）
        定义一个已经存在的接口，这个接口需要适配
    + Adapter（TextShape）
        对Adaptee的接口与Target的接口进行适配
7. 协作
    + Client在Adapter实例上调用一些操作，接着适配器调用Adaptee的操作实现请求
8. 效果
    类适配器和对象适配器有不同的权衡
    + 类适配器：
        + 用一个具体的Adapter类对Adaptee和Target进行匹配。结果是当我们想用匹配一个类以及所有它的子类时，类Adapter不能胜任工作
        + 使得Adapter可以重定义Adaptee的部分行为，因为Adapter是Adaptee的一个子类
        + 仅仅引入类一个对象，并不需要额外的指针以间接得到Adaptee
    + 对象适配器：
        + 允许一个Adapter与多个Adaptee-即Adaptee本身以及其所有子类同时工作，Adapter也可以一次给所有的Adaptee添加功能
        + 使得重新定义Adaptee的行为比较困难，因为这需要生成Adaptee的子类，并且使Adapter引用这个子类而不是Adaptee本身。
        
    + 使用Adapter模式时需要考虑以下因素：
        + Adapter的匹配程度  对Adapter的接口与Target的接口进行匹配的工作量，各个Adapter可能不一样。
        + 可插拔的Adapter  当其他类使用一个类时，如果所需的假定条件越少，这个类的复用性越高
        + 使用双向适配器提供透明操作   使用适配器的一个潜在问题时，它们不对所有的客户端都透明。被适配的对象不再兼容Adaptee的接口，因此并不是
        所有Adaptee对象可以被使用的地方都可以被使用.可以考虑一个双向适配器
9. 实现
    注意以下问题
    + 使用c++实现 Adapter类公共方式继承Target，私有继承Adaptee
    + 可插拔的适配器
        有许多方法可以实现可插拔的适配器，相对来说步骤是这样的，首先为Adaptee找到一个窄接口，因为相对多接口更适合匹配，接口有如下实现：
        + 使用抽象操作 具体子类实现操作
        + 使用代理对象 请求转发，减少子类化
        + 参数化的适配器 无子类化的适配    
12. 相关模式
    模式Bridge的结构与对象适配器相似，但是Bridge的出发点不同，Bridge的目的是将接口和实现部分分离，从而对它们可以较为容易也相对独立的加以改变。
    而Adapter则意味着改变一个已有对象的接口。
    
    Decorator增强了对象功能而同时不改变它的接口，因此Decorator的透明性更好，更支持递归组合
    
    Proxy在不改变它接口的条件下，为另一个对象定义了一个代理
## BRIDGE
1. 意图
    将抽象和实现部分分离，使其可以独立地变化。
2. 别名
    Handle/Body
3. 动机
    当一个抽象有多个实现时，我们通常用继承来实现。抽象类定义对该抽象的接口，而具体子类，则用不同方式加以实现，但有时不够灵活。
    继承机制将抽象部分与实现部分过于耦合，使得难以把抽象和实现独立地进行修改，扩充和重用。
    
    考虑以下情况有个Window抽象类，现有两个子类XWindow，PMWindow，继承的不足之处如下：
    + 扩展Window使之适用不同种类的窗口或者平台不是很方便。假设有个IconWindow 专门处理图标，为了使IconWindow支持之前的子类，我们不得实现XIconWindow,
    PMIconWindow,这岂不很麻烦。
    + 继承机制使得客户代码和平台相关。每当客户创建一个窗口，必须要实例化一个具体的类，这个类有特定的实现部分，这使得很难将客户代码移植到别的平台。
    客户在创建窗口时不应涉及到具体实现，仅仅是窗口的实现部分依赖于平台，这样客户在创建窗口时就不涉及到特定的平台。
    
    Bridge模式的处理方式是将抽象和实现分离，有两层类的结构。其中一个针对窗口接口，其中一个针对实现Impl。
4. 适用性
    以下情况适用Bridge
    + 你不希望抽象和实现直接有一个固定的绑定关系，因为程序运行时可选择或者切换实现
    + 类的抽象以及它的实现都应通过生成子类的方法加以扩充，这时Bridge模式可使你对不同接口和实现进行组合，并分别扩充。
    + 对一个抽象的实现部分修改应对客户不产生影响，即客户端代码不需重新编译
    + 有许多类要生成，这样的类层次，你必须将对象分解成两个部分 "嵌套的普遍化"
    + 想在多个实现里共享实现，但要求客户不知道。
5. 结构
6. 参与者
    + Abstraction(Window)
        + 定义抽象类的接口
        + 维护一个指向实现的指针
    + RefinedAbstraction(IconWindow)
        扩充由Abstraction定义的接口
    + Implementor(WindowImpl)
        定义实现类的接口，这接口不一定要与Abstraction完全一致，事实上可以完全不同，impl提供基本操作，Abstraction定义了基于这些基本操作的较高
        层次的操作
    + ConcreteImplementor(XWindowImpl)
        实现Implementor接口，并定义它的具体实现
8. 效果
    Bridge有以下优点
    + 分离接口和实现 
    + 提高可扩充性
    + 实现细节，客户未知
9. 实现
    注意以下问题：
    + 仅有一个Implementor 仅有一个实现时没必要抽象
    + 创建正确的实现对象 如果有多个Impl实现
    + 共享Impl对象
    + 采用多重继承
11. 应用
    Map接口，Set接口这是种退化的桥接，没有抽象Implementor类
12. 相关模式
    抽象工厂创建和配置一个特定的bridge
    
    适配器用来帮助无关的类协同工作，通常在系统设计完成后才会使用，然而桥接模式在系统开始时就被使用，因为把抽象接口和实现分离。
## COMPOSITE
1. 意图
    将对象组合成树形结构以表示"部分-整体"的层次结构
2. 动机
    比如绘图编辑器和图形捕捉这样的app里，用户可以组装多个简单组件成为一个更大的组件，这些组件又能组装成一个更大的组件。一个简单的实现是为Text和
    Line这样的图元定义一些类，另外定义一些类作为这些图元的容器类。然而这种实现有一个问题，使用这些类的代码必须区别对待图元和容器对象。而大多数情况下
    用户认为他们是一样的。对这些类区别使用，使程序更加复杂。Composite就为了解决这个情况，用递归组合，树形结构，解决了该问题。
    
    Composite的关键是一个抽象类，它即表示图元，又表示图元容器
3. 适用性
    以下情况适用Composite模式：
    + 你想表示对象的部分-整体层次结构
    + 你希望用户忽略组合对象和单个对象的不同，用户统一地使用组合结构中的所有对象。
4. 结构
5. 参与者
    + Component（Graphic）
        + 为组合中的对象声明接口（操作？）
        + 在适当情况下，实现所有类共有接口的缺省行为
        + 声明一个接口用于访问和管理Composite的子组件
        + （可选）在递归结构中定义一个接口，用于访问一个父部件，并在合适的情况下实现它
    + Leaf（Text，Line等）
        + 在组合模式中表示叶节点，叶节点没有子节点
        + 在组合中定义图元对象的操作
    + Composite(Picture)
        + 定义所有子部件的部件们的行为
        + 存储子部件
        + 在Component接口实现与子部件的有关操作
    + Client
        通过Component接口操作组合部件的对象
6. 协作
    用户使用Component类接口与组合结构中的对象进行交互，如果接受者是个叶子节点，直接处理请求，如果是Composite，请求转发给子部件。
7. 效果
    
        
    
    