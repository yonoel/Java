# 结构型模式
## ADAPTER
1. 意图
    将一个类的接口转换成客户希望的另一个接口，使得原本不由于接口不兼容而不能一起工作的类一起工作
2. 别名
    wrapper
3. 动机
    有时，为复用而设计的工具箱类不能被复用的原因仅仅是因为接口不兼容.
    比如，有个绘图编辑器，图形对象的接口为shape的抽象类定义，每种图形都有不同的子类，LineShape，PolygonShape，等等。
    但是TextShape比较难实现，同时工具箱提供类TextView用于显示和编辑文本，理想情况是复用TextView实现TextShape，显然不行，view被封闭了
    
    我们的解决方案只能如下定义TextShape类，适配TextView接口和Shape接口。有两种途径
    1. 继承Shape接口和Text的实现。（多继承）
    2. 将一个TextView的实例作为TextShape的组成部分（成员变量）
    
    这两种方法对应了Adapter模式的类和对象版本，我们将TextShape称之为适配器Adapter
4. 适用性
    以下情况适用Adapter模式
    1. 你想使用一个已经存在的类，而它的接口不符合你的需求
    2. 你想创建一个可以复用的类，该类可以与其他不相关的类或不可预见的类协同工作
    3. （仅适用于适配器对象）你想使用一些已经存在的子类，但是不可能对每一个都进行子类化以匹配它们的接口，对象适配器可以适配它们的父类接口
5. 结构
    1. 类适配器使用多重继承对一个接口和另一个接口进行适配
    2. 对象适配器依赖于对象组合（成员变量）
6. 参与者
    + Target （Shape）
        定义client使用与特定领域相关的接口
    + Client （DrawingEditor）
        与符合Target要求的对象协同工作
    + Adaptee（TextView）
        定义一个已经存在的接口，这个接口需要适配
    + Adapter（TextShape）
        对Adaptee的接口与Target的接口进行适配
7. 协作
    + Client在Adapter实例上调用一些操作，接着适配器调用Adaptee的操作实现请求
8. 效果
    类适配器和对象适配器有不同的权衡
    + 类适配器：
        + 用一个具体的Adapter类对Adaptee和Target进行匹配。结果是当我们想用匹配一个类以及所有它的子类时，类Adapter不能胜任工作
        + 使得Adapter可以重定义Adaptee的部分行为，因为Adapter是Adaptee的一个子类
        + 仅仅引入类一个对象，并不需要额外的指针以间接得到Adaptee
    + 对象适配器：
        + 允许一个Adapter与多个Adaptee-即Adaptee本身以及其所有子类同时工作，Adapter也可以一次给所有的Adaptee添加功能
        + 使得重新定义Adaptee的行为比较困难，因为这需要生成Adaptee的子类，并且使Adapter引用这个子类而不是Adaptee本身。
        
    + 使用Adapter模式时需要考虑以下因素：
        + Adapter的匹配程度  对Adapter的接口与Target的接口进行匹配的工作量，各个Adapter可能不一样。
        + 可插拔的Adapter  当其他类使用一个类时，如果所需的假定条件越少，这个类的复用性越高
        + 使用双向适配器提供透明操作   使用适配器的一个潜在问题时，它们不对所有的客户端都透明。被适配的对象不再兼容Adaptee的接口，因此并不是
        所有Adaptee对象可以被使用的地方都可以被使用.可以考虑一个双向适配器
9. 实现
    注意以下问题
    + 使用c++实现 Adapter类公共方式继承Target，私有继承Adaptee
    + 可插拔的适配器
        有许多方法可以实现可插拔的适配器，相对来说步骤是这样的，首先为Adaptee找到一个窄接口，因为相对多接口更适合匹配，接口有如下实现：
        + 使用抽象操作 具体子类实现操作
        + 使用代理对象 请求转发，减少子类化
        + 参数化的适配器 无子类化的适配    
12. 相关模式
    模式Bridge的结构与对象适配器相似，但是Bridge的出发点不同，Bridge的目的是将接口和实现部分分离，从而对它们可以较为容易也相对独立的加以改变。
    而Adapter则意味着改变一个已有对象的接口。
    
    Decorator增强了对象功能而同时不改变它的接口，因此Decorator的透明性更好，更支持递归组合
    
    Proxy在不改变它接口的条件下，为另一个对象定义了一个代理
## BRIDGE
1. 意图
    将抽象和实现部分分离，使其可以独立地变化。
2. 别名
    Handle/Body
3. 动机
    当一个抽象有多个实现时，我们通常用继承来实现。抽象类定义对该抽象的接口，而具体子类，则用不同方式加以实现，但有时不够灵活。
    继承机制将抽象部分与实现部分过于耦合，使得难以把抽象和实现独立地进行修改，扩充和重用。
    
    考虑以下情况有个Window抽象类，现有两个子类XWindow，PMWindow，继承的不足之处如下：
    + 扩展Window使之适用不同种类的窗口或者平台不是很方便。假设有个IconWindow 专门处理图标，为了使IconWindow支持之前的子类，我们不得实现XIconWindow,
    PMIconWindow,这岂不很麻烦。
    + 继承机制使得客户代码和平台相关。每当客户创建一个窗口，必须要实例化一个具体的类，这个类有特定的实现部分，这使得很难将客户代码移植到别的平台。
    客户在创建窗口时不应涉及到具体实现，仅仅是窗口的实现部分依赖于平台，这样客户在创建窗口时就不涉及到特定的平台。
    
    Bridge模式的处理方式是将抽象和实现分离，有两层类的结构。其中一个针对窗口接口，其中一个针对实现Impl。
4. 适用性
    以下情况适用Bridge
    + 你不希望抽象和实现直接有一个固定的绑定关系，因为程序运行时可选择或者切换实现
    + 类的抽象以及它的实现都应通过生成子类的方法加以扩充，这时Bridge模式可使你对不同接口和实现进行组合，并分别扩充。
    + 对一个抽象的实现部分修改应对客户不产生影响，即客户端代码不需重新编译
    + 有许多类要生成，这样的类层次，你必须将对象分解成两个部分 "嵌套的普遍化"
    + 想在多个实现里共享实现，但要求客户不知道。
5. 结构
6. 参与者
    + Abstraction(Window)
        + 定义抽象类的接口
        + 维护一个指向实现的指针
    + RefinedAbstraction(IconWindow)
        扩充由Abstraction定义的接口
    + Implementor(WindowImpl)
        定义实现类的接口，这接口不一定要与Abstraction完全一致，事实上可以完全不同，impl提供基本操作，Abstraction定义了基于这些基本操作的较高
        层次的操作
    + ConcreteImplementor(XWindowImpl)
        实现Implementor接口，并定义它的具体实现
8. 效果
    Bridge有以下优点
    + 分离接口和实现 
    + 提高可扩充性
    + 实现细节，客户未知
9. 实现
    注意以下问题：
    + 仅有一个Implementor 仅有一个实现时没必要抽象
    + 创建正确的实现对象 如果有多个Impl实现
    + 共享Impl对象
    + 采用多重继承
11. 应用
    Map接口，Set接口这是种退化的桥接，没有抽象Implementor类
12. 相关模式
    抽象工厂创建和配置一个特定的bridge
    
    适配器用来帮助无关的类协同工作，通常在系统设计完成后才会使用，然而桥接模式在系统开始时就被使用，因为把抽象接口和实现分离。
## COMPOSITE
1. 意图
    将对象组合成树形结构以表示"部分-整体"的层次结构
2. 动机
    比如绘图编辑器和图形捕捉这样的app里，用户可以组装多个简单组件成为一个更大的组件，这些组件又能组装成一个更大的组件。一个简单的实现是为Text和
    Line这样的图元定义一些类，另外定义一些类作为这些图元的容器类。然而这种实现有一个问题，使用这些类的代码必须区别对待图元和容器对象。而大多数情况下
    用户认为他们是一样的。对这些类区别使用，使程序更加复杂。Composite就为了解决这个情况，用递归组合，树形结构，解决了该问题。
    
    Composite的关键是一个抽象类，它即表示图元，又表示图元容器
3. 适用性
    以下情况适用Composite模式：
    + 你想表示对象的部分-整体层次结构
    + 你希望用户忽略组合对象和单个对象的不同，用户统一地使用组合结构中的所有对象。
4. 结构
5. 参与者
    + Component（Graphic 最大的抽象）
        + 为组合中的对象声明接口（操作？）
        + 在适当情况下，实现所有类共有接口的缺省行为
        + 声明一个接口用于访问和管理Composite的子组件
        + （可选）在递归结构中定义一个接口，用于访问一个父部件，并在合适的情况下实现它
    + Leaf（Text，Line等）
        + 在组合模式中表示叶节点，叶节点没有子节点
        + 在组合中定义图元对象的操作
    + Composite(Picture)
        + 定义所有子部件的部件们的行为
        + 存储子部件
        + 在Component接口实现与子部件的有关操作
    + Client
        通过Component接口操作组合部件的对象
6. 协作
    用户使用Component类接口与组合结构中的对象进行交互，如果接受者是个叶子节点，直接处理请求，如果是Composite，请求转发给子部件。
7. 效果
    + 定义了包含基本对象和组合对象的层次结构  基本对象可以被组合成更复杂的组合对象，而这个对象又可以被组合，这样不断递归。
    + 简化客户端代码 
    + 更容易增加新类型的组件
    + 使你的设计更加一般化
8. 实现
    考虑以下问题：
    + 显式的父部件引用 保持从子到父的引用能够简化组合结构的遍历和管理。
    + 共享组件 
    + 最大化Component接口 Composite模式的目的是使用户不知道具体操作的Leaf还是Composite，因此Component类应该尽可能多些公共操作（矛盾点）
    + 声明管理子部件的操作 虽然Composite类实现类ADD和Remove用于管理子部件，但是Composite模式里一个重要问题是：在Composite层次里该由哪一些类
    来声明这些操作，是在Component里声明，是操作对leaf有意义呢？还是只在Composite里和它的子类里声明并定义这些操作？这需要在安全性和平衡型里作出
    权衡。
        + 在根部Component里声明，具有良好的透明性，可以一致地使用所有组件。但安全性不佳，比如在Leaf里删除和增加对象。
        + 在Composite里声明，具有良好的安全性，但损失了透明性。
        
    对这一模式我们强调透明性胜过安全性。如果你选择安全性，有时你会丢失类型信息，解决办法：声明一个getComposite的默认操作。同理如果在根部件里声明
    这些操作，又不合理，我们也当提供一个失败的ADD或者Remove操作，或者指向它的Composite来调用。
    
    + Component是否该实现一个Component列表 你可能希望在自身里放一个实例变量，但是这样对leaf节点有点浪费。
    + 子部件排序 
    + 使用缓存存储改善性能 比如你对组合进行频繁的遍历或者查找，Composite里缓存存储对他的子节点的进行操作的信息。
    + 应该由谁来删除Component 在没有垃圾回收时，最好是Composite，但有种情况除外，leaf不会改变，那可以共享
    + 存储组件用哪一种数据结构 
11. 相关模式
    通常部件-父部件连接用于Responsibility Of Chain模式
    
    Decorator 模式共用时，通常有个公共父类
    
    FlyWeight共享组件不可引用父部件
    
    Iterator 可用来遍历 Composite
    
    Visitor 将本来分布在Composite和leaf里但操作和行为局部化
## DECORATOR
1. 意图
    动态给一个对象添加一些额外职责，比生产子类更加灵活
2. 别名
    Wrapper
3. 动机
    我们希望给某个对象而不是整个类添加功能。继承的方式不够灵活，而将组件嵌入另一个对象，这个对象负责添加边框或者功能，这个类被我们称为装饰器。
4. 适用性
    以下情况适合使用
    + 不影响其他对象的情况下，以动态，透明的方式给单个对象添加职责
    + 处理那些可以撤销的职责
    + 当不能用生产子类的方法进行扩充时 一种情况是，可能有大量独立的拓展，为支持每一种组合将产生大量的子类，另一种是因为类定义被隐藏，或者类定义不能生产子类
5. 结构
6. 参与者
    + Component（VisualComponent）  
        定义一个接口对象，可以给这些对象动态的添加职责
    + ConcreteComponent(TextView)
        定义一个对象，可以给这个对象添加职责
    + Decorator()
        维持一个指向Component对象的指针，并定义和Component接口一致的接口
    + ConcreteDecorator（BorderDecorator,ScrollDecorator）
        向组件添加功能
7. 协作
    Decorator将请求转发给它的Component对象，然后附加一些功能
8. 效果
    Decorator有以下两个主要优点和缺点
    + 比静态继承更加灵活
    + 避免在层次结构高层的类有太多的特征
    + Decorator与他的Component不一样 Decorator是一个包装，如果我们从对象的观点出发，一个被装饰了的和其自身是有差别的，使用装饰时不应依赖对象
    + 有许多小对象 会产生很多类似的小对象，很难学习，很难排错
9. 实现
    使用的要点
    + 接口的一致性 装饰对象和所装饰的对象的接口要一致
    + 省略抽象Decorator类 当你只增加一个装饰器时没有必要有抽象类
    + 保持Component类的简单 应集中于操作而不是表示数据
    + 改变对象外壳与改变对象内核 strategy就是改变内核的模式，当Component很庞大时，改变内核更适合。由于装饰是从外部改变，组件对于装饰一无所知，装饰
    对于组件是透明的。而策略模式里，组件本身知道哪里被扩充，因此它必须引用和维护策略。
    另一方面，装饰必须和组件的接口完全相同，而策略不需要。
12. 相关模式
    Adapter模式 装饰器不同于适配器，因为装饰仅改变对象的功能，而不改变接口，而适配器将给予对象新的接口
    
    Composite模式 可以将装饰器看作一个退化的，仅有一个组件的组合，然而装饰的作用在于添加功能，而不是对象聚集
    
    Strategy模式 一个改变内核，一个改变外表
## FACADE
1. 意图
    为子系统中的一组接口提供一个一致的界面，Facade定义了一个高层接口，这个接口使得子系统更加容易使用
2. 动机
    将一个系统划分成几个子系统，解耦。然后Facade相当于一个接口，封装了统一调用子系统的接口。
3. 适用性
    在以下情况需要使用Facade模式
    + 当你要为一个复杂的子系统提供一个简单接口时
    + 客户程序和抽象类的实现部分之间存在着巨大的依赖性
    + 构建一个层次结构的子系统时，使用Facade模式定义系统中每层的入口。简化依赖。
4. 结构
5. 参与者
    + Facade（Compile）
        + 知道哪些子系统类负责处理请求
        + 将客户的请求转发给子类
    + Subsystem Classes（Scanner，Parser，Node等）
        + 实现子系统的功能
        + 处理Facade指派的任务
        + 没有Facade的相关信息，即没有指针指向Facade
6. 协作
    + 客户程序通过发送请求给Facade的方式与子系统通讯，Facade将请求转发
    + 客户不需要直接访问子系统对象
7. 效果
    优点：
    + 对客户屏蔽了子系统组件
    + 实现了松耦合
    + 不限制使用子系统的类，依旧可以调用
8. 实现
    注意点：
    + 降低耦合 用抽象类实现Facade而他的子类对应系统的不同实现，还有一种是用不同的子系统对象配置Facade
    + 公共子系统和私有子系统 类和系统有相似之处，他们都有接口并封装了一些东西，类封装了状态和操作，子系统封装了类。
11. 相关模式
    抽象工厂和Facade一起使用提供一个接口来调用，或者抽象工厂替代Facade隐藏实体
    
    Mediator与Facade相似之处是，都抽象了一些已有的功能，然而Mediator的目的是对同事之间的任意通讯进行抽象，通常集中不属于任何单个对象的功能。Mediator
    的同事对象知道中介者与它通讯，而不是直接与其他同类对象通讯。相对而言，Facade仅对子系统对象的接口进行抽象，从而更任意使用，并不定义新功能，子系统也不知道Facade的存在。
    
    通常来讲，仅需要一个Facade对象，因此Facade对象通常属于单例模式。
## FLYWEIGHT
1. 意图
    运用共享技术有效地支持大量细粒度的对象
2. 动机
    过于基于OO编程，比如一个很小的文档也变成了成千上万个对象，浪费太大内存。flyweight是个共享对象，同时在多个context中使用，并且在每个context里都可以作为一个独立的对象。
    关键概念是内部状态和外部状态，内部状态存储于flyweight，独立于flyweight所处的context，这些信息使得flyweight可以被共享。而外部状态取决于context，不可共享。
    用户对象负责在必要时把外部状态传递给flyweight。
3. 适用性
    flyweight模式的有效性很大程度取决于如何使用它以及在何处使用它，以下情况适合使用：
    + 一个应用程序使用了大量的对象
    + 完全由于使用了大量对象导致很大的存储开销
    + 对象的大多数状态都可以变为外部状态
    + 如果删除对象的外部状态，可以用相对较少的共享对象取代很多对象
    + 程序不依赖于对象标记。
4. 结构
5. 参与者
    + Flyweight（Glyph）
        描述一个接口，通过这个Flyweight可以接受并作用于外部状态
    + ConcreteFlyweight（Character）
        实现flyweight接口，并为内部状态增加存储空间。ConcreteFlyweight必须是可以共享的，它所存储的状态必须是内部的。
    + UnsharedConcreteFlyweight（Row，Column）
        并非所有的Flyweight子类都要求共享，flyweight使得共享成为可能。
    + FlyweightFactory
        + 创建并管理Flyweight
        + 确保合理地共享flyweight
    + Client
        + 维持对Flyweight的引用
        + 计算或存储多个flyweight的外部状态
6. 协作
    + flyweight执行时所需的状态必定是内部或者外部的。内部存储与ConcreteFlyweight里，外部存储于Client里
    + 用户不直接对ConcreteFlyweight进行实例化，只能从工厂里得到对象
7. 传输
    使用此模式时，传输，查找，计算外部状态都影响运行时的开销，空间上的节省抵消了这些开销。存储节约由以下几个因素决定：
    + 因为共享，实例总数减少的数目
    + 对象内部状态的平均数目
    + 外部状态是计算还是存储的
    
    共享的flyweight越多，存储节约就越多，节约量随共享状态的增多而增大，当对象的外部状态是计算而非存储时，节约量最大。因此
    有两种方法节约内部消耗：共享减少内部消耗，计算外部状态。
    
    Flyweight经常和Composite共同使用，叶子节点无法存储父节点的指针，而父节点传给flyweight作为它的外部状态。
8. 实现
    注意点：
    1. 删除外部状态  flyweight模式的可用性很大程度取决于是否容易识别外部状态并将它从共享对象中删除，理想状况是，外部状态可以由一个单独的对象结构
    计算得到，且该结构的存储要求很小。
    2. 管理共享对象   因为对象是共享的，用户不能对其实例化，因此FlyweightFactory帮助用户
11. 相关模式
    Flyweight通常于与Composite模式结合，采用有向无环图实现一个逻辑上的层次结构
    
    最好用Flyweight实现State和Strategy
## PROXY
1. 意图
    为其他对象提供一种代理以控制这个对象的访问
2. 别名
    Surrogate
3. 动机
    一个原因是为了只有我们确实需要这个对象时才进行初始化和创建，DI,依赖注入。这个代理对象在需要时负责实例化实际调用的对象。
4. 适用性
    在需要用比较通用和复杂的对象指针 代替 简单的指针时 使用代理模式。下面是代理模式常见的情况：
    + 远程代理  
    + 虚代理   就是动机一节的例子
    + 保护代理  控制对原始对象的访问。保护代理用于对象应该有不同的访问权限的时候。
    + 智能指引  取代了简单的指针，在访问对象时执行一些附加操作，比如：
        + 对指向实际对象的引用计数，这样当实际对象没有引用时，自动释放
        + 当第一次引用一个持久对象时，将它装入内存
        + 当访问一个实际对象前，检查是否已经锁定
5. 结构
6. 参与者
    + Proxy
        + 保存了一个引用使得代理可以访问实体
        + 提供一个与Subject的接口相同的接口，这样代理就可以代理实体。
        + 控制对实体的存取，并可能负责创建和删除它
        + 其他依赖于代理的功能
            + Remote Proxy 负责对请求和参数进行编码，并向不同地址空间的实体发送编码好的请求
            + Visual Proxy 可以缓存实体的附加信息，以延迟对它的访问
            + Protection Proxy 检查权限
    + Subject
        定义RealSubject和Proxy的共有接口，这样在任何使用RealSubject的地方都可以使用Proxy
    + RealSubject
        定义代理代理的实体
7. 效果
    根据不同的代理功能，实现不同
8. 效果
    代理模式在访问对象时引入了一定程度的间接性，附加的间接性提供了多种用途。
9. 实现
    代理模式可以利用语言的特性：
    + C++里的存取运算符
    + smalltalk里的doseNotUnderstand
    + 代理并不总是需要知道实体的类型
12. 相关模式
    Adapter 为它适配的对象提供一个不同的接口，而代理为它代理的对象提供了相同的接口
    
    Decorator 相似，但是程度有所区别
## 相关讨论
各种模式都有类似点，分别说明一下
### ADAPTER和BRIDGE 
相同：它们都给另一对象提供一定程度的间接性，都涉及到从自身以外的一个接口向这个对象转发请求。

不同：adapter的目的是为了解决两个已有接口的不匹配，注重的是接口的协调。而Bridge对抽象和（多个）实现进行桥接。

adapter多是在类已经设计好，而Bridge是在设计之前实施。而Facade定义了新的接口。
### COMPOSITE DECORATOR PROXY
相同：composite和decorator有类似的结构图，都基于递归组合来组织可变数目的对象。

不同：Decorator旨在使你不需要生成子类来扩展对象，composite旨在构造类，使得多个相关对象能以统一的方式处理。

composite和Decorator有互补性。

相同：decorator和proxy类似，这两种模式都为对象提供一定程度上的间接引用。

不同：结构不同，decorator是基于递归组合而设计的，在proxy里，实体定义了关键功能，而Decorator里实体提供了部分功能。Decorator在编译时（不方便）不能确定对象
的全部功能。而proxy模式强调的是一种关系，可以静态的表达。

当然也可以把Decorator和Proxy结合起来，动态代理。。。

       
        
           

    
    
        
    
    