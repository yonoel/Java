# 行为性模式
 行为模式设计到算法和对象间职责的分配。
 
 行为类模式使用继承机制在类间分派行为。行为对象模式使用对象复合。其他模式将行为封装在对象里。
## CHAIN OF RESPONSIBILITY
1. 意图
    使多个对象都有机会处理请求，从而避免请求的发送者和接受者之间过于耦合。
2. 动机
    这一模式的想法是，给多个对象处理一个请求的机会，从而解耦发送者和接送者。该请求将沿着对象链条传递直至其中一个对象处理它。
    从第一个对象开始，链中的对象要么亲自处理它，要么转发给下一个对象。该请求有一个隐式的接受者（implicit receiver）
3. 适用性
    在以下条件适合使用任务链
    + 有多个对象可以处理一个请求，哪个对象处理该请求运行时刻自动确定
    + 你想在不明确指定接受者的情况下，向多个对象中的一个提交一个请求
    + 可处理一个请求的对象集合应被动态指定
4. 结构
5. 参与者
    + Handler（如HelpHandler）
        + 定义一个可处理请求的接口
        + （可选）实现后继链
    + ConcreteHandler（如PrintButton）
        + 处理它负责的请求
        + 可以访问它的后继者
        + 如果可以处理请求，就处理，否则转发给后继者
    + Client
        + 向链上的具体处理者（ConcreteHandler）提交请求
6. 协作
    当客户提交请求时，请求沿着链条传递直至一个ConcreteHandler处理它
7. 效果
    任务链的优点和缺点：
    + 降低耦合度 职责链简化了对象的相互链接，仅需保持一个对后继者的引用，不需保持它所有后选者的引用
    + 增强了对象指派职责的灵活性 可以在运行时刻对该链条进行动态的增加或修改 来增加或改变 处理一个请求的那些职责
    + 不保证被接受 既然一个请求没有明确的接受者，那么就不能保证它一定会被处理
8. 实现
    下面是在实现过程中要考虑的问题：
    + 实现后继者链
        + 定义新的链接（通常在handler定义，也可由ConcreteHandler来定义）
        + 使用已有的链接
    例子是定义了新的链接，也可以使用已有的链接来形成。比如composite。
    + 链接后继者
        如果没有已有的引用可定义一个链，你必须自己引入。这种情况下Handler不仅定义该请求的接口，通常也维护后继链（默认转发）。
    + 表示请求
        最简单的形式，请求是一个硬编码的操作调用，这种形式方便且安全，但你只能转发Handler定义的固定的一组请求。
        另一种是一个处理函数，这个函数以一个请求码为参数（传递函数），这种方法支持的请求数目不限，但他需要条件语句来区分请求代码，另外无法用类型
        安全的方法来传递。
        
        为标示请求，Request可定义一个访问器（accessor）返回该类的标识符，或者使用运行时的类型信息。
    + 在smallTalk中自动转发
11. 相关模式
    composite和此模式共用，一个构件的父级，可以作为它的后继者（冒泡啊）
## COMMAND
1. 意图
    将一个请求封装为一个对象,从而使你可用不同请求对客户进行参数化，对请求排队或者记录，或者撤销
2. 别名
    Action Transaction
3. 动机
    有时候，必须向某对象提交请求，但并不知道关于被请求但操作或请求但接受者的任何消息。命令模式通过将请求本身变成一个对象来使工具箱对象可向未指定
    的应用对象提出请求。这个对象可被存储并像其他对象一样被传递。注意command模式下解耦了调用操作的对象和具有执行该操作的所需信息的对象。
4. 适用性
    + 如同上面例子里多个对象，抽象出待执行的动作以及参数化某对象。你可以用面向过程中的回调函数来表达这种参数化机制，command是回调机制的一个OO里的替代品
    + 在不同时刻，指定，排列，执行请求。一个command对象可以有一个与初始请求无关的生存期。
    + 支持取消操作
    + 支持修改日志
    + 用构建在原语操作上的高层操作构建一个系统。这样一种结构，在事务的信息系统中很常见，一个事务封装了对数据的一组变动。
5. 结构
6. 参与者
    + Command
        声明执行操作的接口
    + ConcreteCommand
        + 将一个接受者对象绑定于一个动作
        + 调用接受者相应的操作，实现Execute
    + Client
        创建一个具体的命令对象并设定他的接受者
    + Invoker
        要求该命令执行这个请求
    + Receiver
        知道如何实施并执行一个请求相关的操作，任何类都能作为一个接受者
7. 协作
    + Client 创建一个ConcreteCommand对象并指定Receiver对象
    + 某Invoker对象存储该ConcreteCommand对象
    + 该Invoker调用Command的Execute提交请求
    + ConcreteCommand调用他的Receiver的一些操作执行请求
8. 效果
    + 将调用操作的对象和知道如何实现该操作的对象解耦
    + command对象是头等对象，可以像其他对象一样被操纵和扩展
    + 可以将多个command组装一个复合command
    + 增加新的command很容易
9. 实现
    + 一个command对象应达到何种智能程度。一种极是它仅确定接受者和执行该请求的动作，另一种极端是它实现所有功能，不需要额外的接受者。
    + 支持取消和重做 command可能需要额外存储状态信息，这个状态包括
        + 接受者对象，真正的执行者
        + 接受者执行操作时的参数
        + 如果参数会改变，先要保存下来
    + 避免取消操作过程中的错误积累
        在实现一个可靠的，能保持原先语义的取消/重做机制时，可能会遇到滞后影响问题。比如积累错误，这里可以用Memento来让Command访问这些信息而不暴露。
    + 使用c++模板
12. 相关模式
    Composite 用来实现宏命令
    Memento 用来保持某个状态，命令用这一状态去取消操作
    在被放入历史操作记录表前必须被拷贝的命令起到了原型的作用
## INTERPRETER
1. 意图
    给定一种语言，定义文法的表示，并定义解释器，解释器使用该表示来解释语言中的句子
2. 动机
    如果一种特定类型的问题发生的频率足够高，那么就值得将该问题的各个实例表述为一个简单句子，这样就可以构建一个解释器。解释器通过解释这些句子来解决该问题。
    
    比如搜索匹配一个模式字符串这个问题，正则表达式是描述pattern的一种标准语言，与其为每一个pattern构建一个特定的算法，不如使用一个通用的搜索算法来
    解释执行正则表达式。
    
    解释器模式描述了如何为简单的语言定义一个文法，如何在该语言中表示一个句子，以及如何解释句子。
3. 适用性
    当一个语句需要解释执行，并且你可将该语言中但句子表示为一个抽象语法树，可使用解释器模式，有以下情况时该模式效果最好：
    + 该文法简单但对于复杂的文法，文法的类层次变得庞大而无法管理。此时语法分析程序生成器这样的工具是更好的选择，他们无需构建抽象语法树即可表达。
    + 效率不是问题，最高校的解释器通常不是通过直接解释语法分析树实现，而是转换成另一种形式，比如正则变成状态机，但即使在这种情况，转换器扔可用解释器实现
4. 结构
5. 参与者
    + AbstractExpression（抽象表达式，如RegularExpression）
        声明一个抽象的解释操作，这个函数为所有抽象语法树中的所有节点共享
    + TerminalExpression（终结符表达式，如LiteralExpression）
        + 实现文法的终结符相关联的解释操作
        + 每一个语句都需要该类的一个实例
    + NonterminalExpression(非终结表达式，如AlternationExpression，RepetitionExpression，SequenceExpression)
        + 对文法中的每一条规则都需要一个NonterminalExpression
        + 每一个符号都需要维护一个抽象表达式的实例变量
        + 为文法里的非终结符实现解释操作，解释一般要递归地调用表示字符的对象的解释操作
    + Context
        包含解释器之外的全局信息
    + Client
        + 构建或被给定表示该文法定义语言中的一个特定的句子的抽象语法树
        + 调用解释操作
6. 协作
    + client构建一个句子，它是由表达式构建的一个抽象语法树，上下文执行解释操作
    + 为每个非终结的表达式定义相应的解释操作。
    + 每一节点的解释操作 由上下文来管理。
7. 效果
    解释器有如下的优点和缺点：
    + 易于改变和拓展文法 因为该模式用类来表示文法规则，可以使用继承来改变或扩展该文法。已有的表达式可被增量式地改变，而新的表达式可定义为旧表达式的变体。
    + 也易于实现文法 定义抽象语法树中的各个节点的类的实体大体类似，这些类易于直接编写，通常它们可用一个编译器或语法程序生成器自动生成。
    + 复杂的文法难以维护 解释器模式为文法中的每一条规则至少定义了一个类，因此包含许多规则的文法可能难以维护和管理。可应用其他设计模式来缓解这一问题。
    + 增加了新的解释表达式的方式 解释器模式使得实现新表达式计算变得容易
8. 实现
    Interpreter和Composite模式在实现上有许多共通之处，下面是Interpreter的一些特殊问题：
    + 创建抽象语法树 解释器并未结束如何创建一个抽象的语法树。换言之，它不涉及语法分析。抽象语法树可用一个表驱动的语法分析程序来生成，也可以用手写（递归）
    语法分析程序创建，或者直接由Client提供。
    + 定义解释操作 并不一定要在具体子类里定义解释操作，可以用Visitor模式将解释放入一个独立的访问者对象更好。
    + 于Flyweight模式共享终结符
11. 相关模式
    Composite 抽象语法树是一个复合模式的实例
    Flyweight 共享终结符
    Iterator  用迭代器遍历
    Visitor  可以用来在一个类中维护抽象语法树的各节点行为
# ITERATOR
1. 意图
    提供一种方法顺序访问一个聚合对象各个元素，而不暴露该对象的内部表示
2. 别名
    Cursor 游标
3. 动机
    一个聚合的对象，比如list，应该提供一种方法来让别人可以访问它的元素，而不暴露其自身的数据结构。迭代器可以解决这个问题，关键思想是将对列表的访问和遍历
    从对象中分离，并放入迭代器里。迭代器定义里一个访问该列表元素的接口，迭代去对象负责跟踪当前的元素。
4. 适用性
    迭代器可以用来
    + 访问一个聚合对象的内容而不必暴露内部的数据结构
    + 支持聚合对象的多种遍历
    + 为遍历不同聚合对象提供了一个统一的接口（即支持多态迭代）
5. 结构
6. 参与者
    + Iterator （迭代器）
        迭代器定义访问和遍历元素的接口
    + ConcreteIterator
        + 具体迭代器实现接口
        + 对该聚合遍历时跟踪当前位置
    + Aggregate
        聚合类定义创建相应迭代器对象的接口
    + ConcreteAggregate
        具体聚合实现创建相应迭代器对接口，返回一个具体迭代器对实例
7. 协作
    ConcreteIterator跟踪聚合中的当前对象，并能够计算出待遍历的后继对象
8. 效果
    迭代器主要有三个重要的作用
    1.  它支持以不同的方式遍历一个聚合
    2.  迭代器简化类聚合的接口  聚合本身不需要提供类似遍历的接口
    3.  在同一个聚合上可以由多个遍历
9. 实现
    迭代器常常需要根据所用语言提供的控制结构来进行权衡，某些语言直接支持了迭代器
    1. 谁该控制迭代   由客户来控制迭代，被成为外部迭代器，由迭代器控制时，称为内部迭代。使用外部必须主动推进迭代，而内部，只需提交一个待执行的操作，
    迭代器自身去对每一个元素实现。外部迭代器更加灵活，内部迭代器更加容易使用
    2. 谁定义遍历算法  迭代器不是唯一可以定义遍历算法的地方，聚合本身也可以定义，并在遍历过程中用迭代器来存储当前的迭代状态，我们称这种迭代器为一个
    游标，因为它仅用来指示当前位置，客户会以这个游标为参数调用该聚合的next，next改变游标。
        如果由迭代器负责遍历，那么将易于在相同的聚合上使用不同的迭代算法，同时也易于在不同的聚合桑使用相同的迭代算法，但是这样遍历算法可能需要访问
        聚合的私有变量，那么就破会了聚合的封装性。
    3. 迭代器健壮程度如何    在遍历一个聚合的同时更改它是危险的。简单的解决方案是备份它，但是成本又太高。一个健壮的迭代器在你对元素操作时，不会干扰遍历，
    且不需要备份该聚合。
    4. 附加的迭代器操作 比如First，isDone，CurrentItem，Previous，SkipTo
    5. 在C++中使用多态的迭代器 使用多态迭代器是有代价的，要求一个工厂函数动态的分配迭代器对象，因此当且仅当需要时使用，否则使用在栈中分配内存的具体
    的迭代器，另一个缺点是，客户必须负责删除它。代理模式是一个补救方案。
    6. 迭代器可有特权访问 迭代器可被看为创建它的聚合的一个扩展，迭代器和聚合紧密耦合，在C++中可以让迭代器作为它的Friend来表示这种关系。但是这种关系可能使
    定义新的遍历变得困难。为避免这种问题，迭代器可包含一些protected来访问该聚合的非公共可见方法，由其子类来重写，来访问该聚合对象。
    7. 用于复合对象的迭代器   比如Composite模式，外部迭代器难以实现，因为该对象的数据结构处于嵌套的不同层次，因此若用外部迭代器，必须有一条纵贯
    该Composite的路径。反而用内部迭代器更好，隐藏了路径在调用栈，无需维护当前对象位置。
    如果复合对象有一个接口可以从一个节点移到兄弟节点，父节点，子节点，那么基于游标的迭代器更好。
    复合对象常常需要多种迭代方式，需要不同的遍历的算法。
    8. 空迭代器 是一个退化的迭代器，处理边界条件，总是已经完成了遍历。
10. 代码实现
11. 已知应用
12. 相关模式
    Composite模式 迭代器经常使用在复合对象上
    Factory Method 多态迭代器靠工厂函数来实例化适当的迭代器
    Memento 常与迭代器一起使用，可以使用一个中间件来捕获一个迭代状态，迭代器在其内部存储Memento
## MEMENTO

    
    
    
        
        
        
    