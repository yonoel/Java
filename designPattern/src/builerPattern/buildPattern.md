# 创建型模式
## ABSTRACT FACTORY
1. 意图
    提供一个创建一系列相关或相互依赖对象的接口，而无需指定他们具体的类。
2. 别名
    kit
3. 动机
4. 实用性
    + 一个系统要独立于它的产品的创建，组合和表示
    + 一个系统要由多个产品系列中的一个来配置
    + 当你要强调一系列相关产品对象的设计以便于联合使用
    + 当你提供一个产品类库，而只想显示他们的接口而不是实现
5. 结构图
6. 参与者
    + AbstractFactory
        声明一个创建抽象产品对象的操作接口
    + ConcreteFactory
        实现创建具体产品的操作
    + AbstractProduct
        为一类产品对象声明一个接口
    + ConcreteProduct
        定义一个将被相应的具体工厂创建的对象，实现了AbstractProduct接口
    + Client
        仅使用由AbstractFactory，AbstractProduct类声明的接口
7. 协作
    + 通常在运行时创建ConcreteFactory的实例
    + AbstractFactory将产品对象的创建延迟到它的ConcreteFactory子类

8. 效果（优缺点）
    + 分离了实现类
    + 易于交换具体要实现的类
    + 利于产品的一致性
    + 难以支持新的类

9. 实现
实现抽象工厂的小技巧
    + 单例模式
    + 创建产品，使用工厂模式，或者原型对象，比如object-c，smalltalk
    + 定义可拓展的工厂，传一个参数对象来表示需要的具体对象，但是不安全可更灵活
11. 相关模式
    抽象工厂用工厂方法实现，也可以用prototype实现，一个具体的工厂通常是singleton
## BUILDER 
1. 意图
    将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示
2. 动机
    一个RTF（rich text format）文档交换格式的阅读器能将RTF 转为多种格式，问题是在于可能的转换数目是无限的，因此要能很容易实现新的转换的增加，
    同时不改变RTF
    
    一种思路是用一个可以将RTF转换成另一种正文表示的TextConverter 对象，配置这个RTFReader类。当RTFReader去解析这个RTF时，实际上是
    TextConverter在做转换。TextConverter的子类对不同转换和不同格式进行处理，每个转换器类都将创建一个复杂对象的机制隐藏在抽象接口后面。
    转换器独立于阅读器，阅读器对每个RTF 进行语法解析。
    这其中我们称转换器为builder，而阅读器为director。
3. 适用性
    在以下情况使用builder模式
    + 当创建复杂对象的算法应该独立于该对象的组成部分和他们的装配方式
    + 当构造过程必须允许被构造的对象有不同的表示时
4. 结构
5. 参与者
    + Builder (TextConverter)
        为创建一个Product对象的各个部件指定抽象接口
    + ConcreteBuilder 
        + 实现Builder接口以构造和装配product的各个部件
        + 定义并明确它创建的表示
        + 提供一个检索产品的接口
    + Director （RTFReader）
        构造一个使用Builder的对象
    + Product
6. 协作
7. 效果
    + 使你可以改变一个产品的内部表示
    + 将构造代码和表示代码分离
    + 对构造过程更精细的控制
8. 实现
    1. 装配和构造接口 生成器逐步构造它们的产品，因此builder类接口必须足够普通以便为各种类型的具体生成器构造产品
        比如当你需要访问前面已经构造了产品部件。
    2. 为什么产品没有抽象类 因为由具体生成器生成的产品，表示相差如此之大，以至于给不同的产品父类没有多大意义
    3. 在builder里默认为午餐构造
9. 代码示例
11. 相关模式
    抽象工厂和构造器相似。主要的区别是，构造器着重于一步步构造一个复杂对象，而抽象工厂着重于构造多个系列的产品对象（简单或者复杂）。
    构造器在最后一步返回对象，抽象工厂立即返回。
    
    composite通常由构造器生成
## FACTORY METHOD
1. 意图
    定义一个用于创建对象的接口，让子类决定实例化哪一个类。工厂方法使一个类的实例化延迟到其子类
2. 别名
    虚构造器
3. 动机
    框架使用抽象类定义和维护对象之间的关系。这些对象的创建也由框架负责。
    在一个框架里，两个主要的抽象类是Application和Document类，客户必须通过他们的子类来实现具体的应用实现。
    因为被实例化的Document子类是和特定应用相关的，所以application类不能预测到哪个document将被实例化，
    仅知道需要被创建。
    工厂方法封装了document子类的创建信息，并从框架里抽离出来。
4. 实用型
    在下列情况适合factory method
    + 当一个类不知道它必须创建的对象的类的时候
    + 当一个类希望由他的子类来指定它所创建的对象的时候
    + 当类将创建对象的职责委托给多个帮助子类中的某一个，并且你希望将那个帮助子类是代理者的信息局部化的时候。
5. 结构
6. 参与者
    + Product（Document）
        定义工厂方法所创建对象的接口
    + ConcreteProduct（MyDocument）
        实现上面的接口
    + Creator（Application）
        声明工厂方法，该方法返回一个Product类型，Creator也可以定义一个默认的创造
        可以调用工厂创建Product
    + ConcreteCreator（MyApplication）
        重定义工厂方法
7. 协作
    + creator依赖于它的子类来定义工厂方法，所以它返回一个适当的concreteProduct对象
8. 效果
    工厂方法不再将特定应用有关的类绑定到代码里，代码仅处理product接口，因此它可以与用户定义的concreteProduct一起使用
    
    工厂的一个缺点是，客户可能仅仅为了创建一个特定的concreteProduct对象就不得不创建creator的子类。
    
    下面是工厂方法的另外两种副作用
    1. 为子类提供挂钩 用工厂方法在一个类内部创建对象比直接创建对象更灵活
    2. 链接平行的类层次 当一个类将它的职责委托给另一个独立类时，就产生了平行层次
9. 实现
    当应用此模式时，应考虑以下问题
    + 主要有两种不同的情况 工厂方法有两种不同的情况： 
        + creator是抽象类且不提供它声明的工厂方法的实现
        + creator是一个具体的类且提供一个默认实现（不常见）
    
    第一种情况需要子类来定义实现，因为没有默认实现，避免了不得不实例化 不可预见类的问题；
    第二种情况则，creator更灵活，遵循的准则是，用一个独立的操作创建对象，这样子类才能重定义他们的创建，保证了子类的创建者能构在必要的时候改变父类
    示例化的对象的类
    
    + 参数化工厂方法 工厂方法采用一个标识要被创建的对象的种类的参数。工厂方法共享Product接口。。方便拓展
    + 特定语言的问题 
    + 使用模版以避免创建子类 
    + 命名约定
12. 相关模式
    抽象工厂使用工厂方法来实现；工厂方法通常在Template Method中被调用；prototype不需要创建creator子类，但是需要一个initialize  product的操作。
## PROTOTYPE
1. 意图
    用原型实例指定创建对象的种类，并通过拷贝这些原型来创建新的对象。
2. 动机
    通过定制一个通用的图形编辑器框架和增加音符这类吧啦吧啦的对象来构造一个乐谱编辑器。
    假定框架为图形构件的抽象类为Graphics，工具类为Tool，预定义了一个GraphicsTool子类。
    但这个GraphicsTool子类带来了问题，音符和五线谱的类特定于app，但是这个类却只属于框架。
    GraphicsTool不知道如何创建我们app的对象，并使用它。我们当然可以为我们的每一个对象创建一个GraphicsTool的子类，但这样会产生大量的子类。
    
    解决办法是，让graphicsTool通过拷贝或者clone一个graphic子类的实例来创建新的graphic，我们称这个实例为一个原型。
 graphicsTool将它应该克隆和添加到文档中到原型作为参数，如果所有  graphic都支持一个clone操作，那么  graphicsTool可以克隆所有都graphic
3. 适用性
    当一个系统应该独立于它的产品的创建，构成和表示时，采用原型对象模式。以及
    + 当要实例化的类是在运行时指定的，比如动态装载
    + 为了避免创建一个与产品类层次平行的工厂类层次
    + 当一个类的实例只能有几个不同状态组合的一种时，建立原型并克隆，比每次采用合适的状态手工实例化更方便
4. 结构
5. 参与者
    + Product（Graphic）
        声明一个克隆自身的接口
    + ConcretePrototype
    + Client
        让一个原型克隆自身从而创建新的对象
6. 协作
    + 客户端请求一个原型克隆自身
7. 效果
    prototype 有许多和 abstractFactory和Builder一样的效果，都对客户隐藏类具体product类，此外这些模式使客户无需改变即可使用与特定应用相关的类。
    
    优点：
    + 运行时增加和删除产品
    + 改变值以指定新对象 极大得减少了系统所需要的类
    + 改变结构以指定新对象 深度克隆 
    + 减少子类的构造 FactoryMethod 经常产生一个与产品类层次平行的Creator，而原型使你克隆一个原型而不是请求工厂方法生成一个新的对象。
    + 用类动态配置app 动态加载
    
    缺陷：每个原型对象的子类必须实现clone操作，比如当所考虑的类已经存在时就难以新增clone，当内部存在一些不支持拷贝或者有循环引用的对象时，也很困难。
8. 实现
   c++这样的静态语言，类不是对象，运行时只能得到很少或者得不到信息，那么原型很有用。对于Object-c，原型不那么重要因为这些语言提供了一个等价于原型
   的东西。
   
   当实现原型时需考虑以下问题：
   + 使用一个原型管理器
        方便管理和查找
   + 实现克隆操作
        注意浅拷贝和深拷贝
   + 初始化克隆对象   
        在克隆操作时传参过于耦合，因此每个需要克隆的子类可能还需要初始化操作
11. 相关模式
    原型模式和抽象工厂在某些方面是互相竞争的，但是也可以一起使用；大量使用Composite和Decorator会使用原型对象
    
## SINGLETON

1. 意图
    保证一个类仅有一个实例，并提供一个访问它的全局访问点
2. 动机
    让类自身负责保存它的唯一实例，这个类可以保证没有其他实例可以被创建
3. 适用性
    在下面的情况使用单例模式
    + 当类只能有一个实例而且客户可以从一个访问点访问他
    + 当这个唯一实例应该是通过子类化可扩展的，并且客户无需更改代码就能使用一个扩展的实例时。
4. 结构
5. 参与者
    + Singleton
        定义一个instance操作，允许客户访问，instance是一个类操作，即是c++里的静态函数
        可能负责创建它的唯一实例
6. 协作
    + 客户只能通过instance操作访问一个实例
7. 效果
    有许多优点
    + 对唯一实例的受控访问
    + 缩小命名空间 对全局变量的一种改进
    + 允许对操作和表示的精细化 singleton可以有子类
    + 允许可变数目的实例
    + 比类操作更灵活 另一种方式是使用类操作
8. 实现
    下面是应当考虑的问题
    1. 保证一个唯一的实例 单例模式使得这个唯一实例是类的一般实例，但该类被写成只有一个实例能被创建。做到这一点是将创建操作隐藏在一个类操作（即一个
    静态成员函数或者一个类方法）后面
    
    在C++里的一个例子，注意构造是保护型的，但是在c++里将单件定义为一个全局或静态对象，然后依赖于自动的初始化，这是不够的，原因有以下
        + 我们不能保证静态对象只有一个实例会被声明
        + 我们可能没有足够的信息在静态初始化时 实例化每一个单件，单件可能需要在程序执行中稍后算出来的值
        + c++里没有定义转换单元上全局对象的构造器的调用顺序，这意味着单件不存在依赖关系。
    
    使用全局/静态对象的实现还有一个缺点，所有单件无论是否用到都要被创建，而使用静态成员函数避免了这些问题。
    
    2. 创建singleton的子类
        与其说是定义子类，不如说是建立它的唯一实例。
            一种是，事实上指向单件实例的变量必须用子类的实例进行初始化。
            另一种解决方案是将instance方法从父类中抽离并将它放入子类，但是对客户隐藏，c++在
            链接时决定单件的类，这使得难以在运行时刻选择单件类，这些硬性规定可能的singleton的实例。
            这两种解决方案都不够灵活。
            
        更灵活的办法是使用一个注册表。但是哪里去实例这个注册表呢，又需要一层封装一个静态类来注册它。
9. 相关模式
    很多模式可以使用单例模式
## 相关讨论
用一个系统创建的那些对象的类 对 系统进行参数化有两种常用方法。
+ 一种是生成创建对象的类的子类，应对与工厂方法模式，缺点是，仅为了改变产品类，可能就需要一个新的子类的工厂，这样的改变是联级的。
+ 依赖于对象复合，定义一个对象 负责明确产品对象的 类，并将它作为系统的参数。这就是抽象工厂，原型，构造器的模式。这三个都涉及到创建一个新的负责创建
产品对象的"工厂对象"。

当需要大量对象时，且不改变对象的状态或者子类可以很容易重定义操作时，不如考虑原型或者构造器。通常有工厂方法开始，当需要发展时在考虑新的模式。


  
    

    



        