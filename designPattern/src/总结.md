# 设计模式

## 简介

神书，把软件设计的模式基本囊括了，但切记不要为了模式而模式，必须要有情景才好使用，否则
反而增加了阅读难度。

## 构造模式

1.  抽象工厂    abstract factory 多个类组合
2.  构造器      builder 一个类字段太多时使用
3.  工厂方法    factory method  通用，便于管理
4.  原型对象    prototype 可拷贝对象
5.  单例模式    SINGLETON   保证一个类仅有一个实例，并提供一个访问它的全局访问点

## 结构性模式

1.  适配器      adapter 包裹起来，将一个类的接口转换成客户希望的另一个接口，使得原本不由于接口不兼容而不能一起工作的类一起工作，对同一实现提供不同接口。
    1. 多继承
    2. 作为组成部分（成员变量）
2.  桥接       bridge 将抽象和实现部分分离，使其可以独立地变化。是针对同一接口进行扩展与实现操作的一种设计模式。就是接口
3.  组合       composite  将对象组合成树形结构以表示"部分-整体"的层次结构


4.  装饰器     decorator   动态给一个对象添加一些额外职责，比生产子类更加灵活


5.  外观       facade      为子系统中的一组接口提供一个一致的界面，Facade定义了一个高层接口，这个接口使得子系统更加容易使用
6.  享元       flyweight  运用共享技术有效地支持大量细粒度的对象
7.  代理       proxy      为其他对象提供一种代理以控制这个对象的访问

各种模式都有类似点，分别说明一下
1. ADAPTER和BRIDGE 
    +   相同：它们都给另一对象提供一定程度的间接性，都涉及到从自身以外的一个接口向这个对象转发请求。

    +   不同：adapter的目的是为了解决两个已有接口的不匹配，注重的是接口的协调。而Bridge对抽象和（多个）实现进行桥接。adapter多是在类已经设计好，
    而Bridge是在设计之前实施。而Facade定义了新的接口。
    
2.  COMPOSITE DECORATOR PROXY
    +   相同：composite和decorator有类似的结构图，都基于递归组合来组织可变数目的对象。

    +   不同：Decorator旨在使你不需要生成子类来扩展对象，composite旨在构造类，使得多个相关对象能以统一的方式处理。

    +   composite和Decorator有互补性。

    +   相同：decorator和proxy类似，这两种模式都为对象提供一定程度上的间接引用。

    +   不同：结构不同，decorator是基于递归组合而设计的，在proxy里，实体定义了关键功能，而Decorator里实体提供了部分功能。
    Decorator在编译时（不方便）不能确定对象的全部功能。而proxy模式强调的是一种关系，可以静态的表达。
    当然也可以把Decorator和Proxy结合起来，动态代理。。。
    
## 行为模式

行为模式涉及到算法和对象间职责的分配。行为模式使用继承机制在类间分派行为。
行为对象模式使用对象复合。其他模式将行为封装在对象里。

1.  调用链  CHAIN OF RESPONSIBILITY     使多个对象都有机会处理请求，从而避免请求的发送者和接受者之间过于耦合。
2.  命令    COMMAND 将一个请求封装为一个对象,从而使你可用不同请求对客户进行参数化，对请求排队或者记录，或者撤销
3.  解释器  INTERPRETER    给定一种语言，定义文法的表示，并定义解释器，解释器使用该表示来解释语言中的句子
4.  迭代器  ITERATOR 提供一种方法顺序访问一个聚合对象各个元素，而不暴露该对象的内部表示
5.  中间件  Mediator   用一个中介对象封装一系列的对象交互。中介者对象使得对象不需要显式地相互引用，从而松散耦合。
6.  备忘录  MEMENTO   在不破坏封装的前提下，捕获一个对象的内部状态，并在对象之外保存这个状态，这样以后就可将对象恢复到原先保存了的状态   
7.  观察者  Observer   定义对象间一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象得到通知并且自动更新
8.  状态    state     允许一个对象在其内部状态改变时改变它的行为，对象看起来似乎修改了它的类。
9.  策略    STRATEGY  定义一系列算法，把它们封装，使它们可以互相转换，本模式使得算法可独立于使用它的客户而变化
10.  模板方法 Template Method 定义一个操作的骨架，而将一些实现步骤延迟到子类，子类可以在不改变一个算法的结构即可重新定义该算法的某些步骤
11. 观光者  Visitor    表示一个作用于某对象结构中各个元素的操作，它使你可以在不改变各个元素的类的前提下定义作用于这些元素的新操作

行为模式的根本就是封装了行为（变化）。这些模式通常定义一个抽象类来描述这些封装变化的对象，并以此来命名模式。

大多数模式连接着各种对象，封装该方面特征的新对象，和使用这些新对象的已有对象。如果不使用这些模式，新对象可能成为
旧对象难以分割的一部分，但也不是所有模式具有这样的分割功能，如职责链，职责链体型来行为模式间的另一个不同点，并非所有
行为模式都定义类之间的静态通信关系。指责链就是提供数目可变的对象间进行通信，其他模式则涉及一些作为参数传递的对象。

+   对象作为参数
    一些模式总是被用在参数的对象，如Visitor，Command（宽接口，不同状态下的扔给不同的执行者），
    Memento（仅仅是存储部分状态）。区别在Memento是个窄接口，而Command是多态，而Visitor不是它所访问的元素的一部分。
    
+   通信应该被封装还是封闭
    Mediator和Observer互相竞争的模式，一个是封装了通信，中间件管理了通信，便于理解，难以复用。
    一个是开放通信，由Observer和Subject共同维护通信，便于复用，难以理解。
    
+   对发送者和接受者解耦
    +   command，observer，mediator，chain of responsibility都涉及了解耦，又有不同的考虑。
    +   Command将发送者和接受者之间的链接定义在一个单独的对象使得该发送者可以和不同的接受者一起工作，使发送者更有复用性。
    +   Observer定义一个接口来通知目标中发生的改变，尤其适合数据依赖，需要多个接受者时。
    +   Mediator则把所有通信封装（DISPATCHER啊！！！），各个对象仅能通过中间件交流。
    +   Chain of responsibility则是提供链式的传播
    
## 模式设计原则

1.  单一职责原则

2.  里氏替换原则  Inheritance should ensure that any property proved about supertype objects also holds for subtype objects。子类可以替换超类

3.  依赖倒置原则  高层模块不应该依赖低层模块，二者都应该依赖其抽象；抽象不应该依赖细节；细节应该依赖抽象。

4.  接口隔离原则 其实类似1.保证

5.  迪米特法则   一个对象应该对其他对象保持最少的了解，降低耦合度
      
   






    


 